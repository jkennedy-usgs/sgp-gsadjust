#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
GSadjust, for the interactive network adjustment of relative-gravity networks
=============================================================================
Jeff Kennedy, USGS
jkennedy@usgs.gov

GSadjust is a Python 3.6/PyQt5 program that provides a graphical user interface for post-processing combined
relative- and absolute- gravity surveys.

GSadjust was originally based on PyGrav:
Hector, B. and Hinderer, J.: pyGrav, a Python-based program for handling and
processing relative gravity data, Computers & Geosciences, doi:10.1016/j.cageo.2016.03.010, 2016.

GSadjust is distributed with the network adjustment software Gravnet (Windows executable)
(Hwang, C., C. Wang and L. Lee. 2002. Adjustment of relative gravity measurements
using weighted and datum-free constraints. Computers & Geosciences 28 1005-1015)

This software is preliminary, provisional, and is subject to revision. It is being provided to meet the need for
timely best science. The software has not received final approval by the U.S. Geological Survey (USGS). No warranty,
expressed or implied, is made by the USGS or the U.S. Government as to the functionality of the software and related
material nor shall the fact of release constitute any such warranty. The software is provided on the condition that
neither the USGS nor the U.S. Government shall be held liable for any damages resulting from the authorized or
unauthorized use of the software.

GSadjust file organization is:

GSadjust.py:
  major PyQt elements (tabs, menus)
tab_data.py
  PyQt elements on the data tab
tab_drift.py
  PyQt elements on the drift tab
tab_network.py
  PyQt elements on the network adjustment tab
menus.py
  Creates PyQt menus
gui_objects.py:
  minor PyQt elements (popup windows/dialogs)
data_objects.py:
  Non Py-Qt data objects (Deltas, Datums, etc.)
  Network adjustment code
pyqt_models.py:
  PyQt-specific data models: ObsTreeSurvey, ObsTreeLoop, etc.
tide_correction.py:
  Earth tide and ocean loading code
synthetic_tides.py:
  Tide model coefficients
a10.py:
  Parses *.project.txt files generated by 'g' software (A-10 and FG-5 absolute-gravity meters)

PyQt models follow the PyQt CamelCase naming convention. The other methods/functions in GSadjust use PEP-8
lowercase_underscore convention.

The general data structure of the program is stored as PyQt objects inherited from QStandardItem:

+------------+
| Campaign   |
++-----------+
 |  +---------------------------+
 +--+ Surveys (ObsTreeSurvey)   |
    ++--------------------------+
     |  +-------------+
     +--+ Adjustment  |
     |  +-------------+
     |  +-------------+
     +--+ datum_model |
     |  +-------------+
     |  +-------------+
     +--+ delta_model |
     |  +-------------+
     |  +---------------+
     +--+ results_model |
     |  +---------------+
     |  +----------------------+
     |--+ Loops (ObsTreeLoop)  |
        ++---------------------+
         |  +--------------+
         +--+ delta_model  |
            +--------------+
         |  +-------------+
         +--+ tare_model  |
            +-------------+
         |  +----------------------------+
         +--+ Stations (ObsTreeStation)  |
            ++---------------------------+
             |  +--------------------+
             +--+ g, lat, long, etc. |
                +--------------------+

The Adjustment object in each ObsTreeSurvey holds the network adjustment input, output, and options. There is one
Adjustment per Survey.

The datum_model, delta_model, results_model, and tare_model are PyQt models. The gui is update with the respective
model when a new Survey or Loop is selected (by double-clicking in the tree view). There is one of each table per
Survey.

"""

import copy
import logging
import os
# Standard library modules
import sys
import time
import traceback
import webbrowser

# Modules that must be installed
import numpy as np
from PyQt5 import QtGui, QtCore, QtWidgets
from PyQt5.QtCore import QSettings
from matplotlib.dates import num2date
from data_analysis import compute_gravity_change
from data_correction import time_correction
from data_export import export_metadata, export_summary, export_data
# GSadjust modules
from data_import import (
    read_csv, read_burris, read_cg6, read_cg6tsoft, read_cg5,
    import_abs_g_complete, import_abs_g_simple
)
from data_objects import Datum, Tare, ChannelList, Delta
from gsa_plots import (
    PlotLoopAnimation, PlotDatumComparisonTimeSeries, PlotGravityChange,
    PlotNetworkGraph, PlotDatumCompare, PlotDgResidualHistogram
)
from gui_objects import (
    AddDatumFromList, CoordinatesTable, ProgressBar, ShowCalCoeffs,
    GravityChangeTable, TideCorrectionDialog, TideCoordinatesDialog, DialogApplyTimeCorrection,
    VerticalGradientDialog, AddTareDialog, DialogMeterType, LoopTimeThresholdDialog, DialogOverwrite,
    show_message, SelectAbsg, AdjustOptions, DialogLoopProperties, AboutDialog
)
from menus import Menus, MENU_STATE
from pyqt_models import (
    BurrisTableModel, ScintrexTableModel, ObsTreeModel, TareTableModel,
    ObsTreeStation, ObsTreeLoop, ObsTreeSurvey
)
from tab_data import TabData
from tab_drift import TabDrift
from tab_network import TabAdjust
from tide_correction import tide_correction_agnew, tide_correction_meter
from utils import *
import resources

DOWN = 1
UP = -1
DIRECTIONS = (UP, DOWN)


class MainProg(QtWidgets.QMainWindow):
    """
    GSadjust main routine
    """
    path_output = None
    drift_lookup = {'none': 0, 'netadj': 1, 'roman': 2, 'continuous': 3}
    obsTreeModel = ObsTreeModel()
    previous_loop = None
    previous_survey = None
    vertical_gradient_interval = 64.2
    workspace_loaded = False
    DPI = 60  # resolution for data plots
    all_survey_data = None

    # PyQt indexes
    index_current_survey = None
    index_current_loop = None
    index_current_station = None
    index_current_loop_survey = None
    index_current_station_loop = None
    index_current_station_survey = None

    label_adjust_update_required_set = False
    label_deltas_update_required_set = False

    gui_obstreeview_popup_menu = None
    menus, selection_model = None, None
    tab_data, tab_drift, tab_adjust = None, None, None
    station_model = None
    workspace_savename = None

    def __init__(self, splash=None):
        super(MainProg, self).__init__()

        self.settings = QSettings('SGP', 'GSADJUST')
        self.init_settings()
        self.settings.sync()

        self.menus = Menus(self)
        # self.setGeometry(50, 50, 350, 300)
        self.setWindowTitle('GSadjust')

        # tab_....s are populated with GUI elements in the tab_...() functions
        self.tab_data = TabData(self)
        self.tab_drift = TabDrift(self)
        self.tab_adjust = TabAdjust(self)
        self.tab_widget = QtWidgets.QTabWidget()

        self.tab_widget = QtWidgets.QTabWidget()
        self.tab_widget.addTab(self.tab_data, 'Data')
        self.tab_widget.addTab(self.tab_drift, 'Drift')
        self.tab_widget.addTab(self.tab_adjust, 'Network Adjustment')
        self.tab_widget.setStyleSheet("QTabBar::tab { font-size: 12pt; height: 40px; width: 250px }")
        self.tab_widget.currentChanged.connect(self.tab_changed)

        self.gui_treeview_widget = QtWidgets.QWidget()
        self.gui_treeview_box = QtWidgets.QVBoxLayout()
        self.gui_data_treeview = QtWidgets.QTreeView()

        self.qtaction_move_station_up = QtWidgets.QAction(QtGui.QIcon(':/icons/up.png'), 'Move survey up',
                                                          self)
        self.qtaction_move_station_up.triggered.connect(slot=lambda: self.move_survey(UP))
        self.qtaction_move_station_down = QtWidgets.QAction(QtGui.QIcon(':/icons/down.png'),
                                                            'Move survey down',
                                                            self)
        self.qtaction_move_station_down.triggered.connect(slot=lambda: self.move_survey(DOWN))
        self.gui_toolbar = QtWidgets.QToolBar()
        self.gui_toolbar.addAction(self.qtaction_move_station_up)
        self.gui_toolbar.addAction(self.qtaction_move_station_down)

        self.qtaction_collapse_all = QtWidgets.QAction(QtGui.QIcon(':/icons/ca.png'), 'Collapse all', self)
        self.qtaction_collapse_all.triggered.connect(slot=self.gui_data_treeview.collapseAll)
        self.qtaction_expand_all = QtWidgets.QAction(QtGui.QIcon(':/icons/ea.png'), 'Expand all', self)
        self.qtaction_expand_all.triggered.connect(slot=self.gui_data_treeview.expandAll)

        self.gui_toolbar.addAction(self.qtaction_collapse_all)
        self.gui_toolbar.addAction(self.qtaction_expand_all)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjustCurrent)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjust)
        self.gui_toolbar.addAction(self.menus.mnAdjUpdateSD)

        self.gui_treeview_box.addWidget(self.gui_toolbar)
        self.gui_treeview_box.addWidget(self.gui_data_treeview)
        self.gui_treeview_widget.setLayout(self.gui_treeview_box)

        self.gui_main_window_splitter = QtWidgets.QSplitter(QtCore.Qt.Horizontal)
        self.gui_main_window_splitter.addWidget(self.gui_treeview_widget)
        self.gui_main_window_splitter.addWidget(self.tab_widget)
        self.setCentralWidget(self.gui_main_window_splitter)

        # Setup statusbar icons
        self.update_deltas_text = QtWidgets.QLabel("Update delta table:", self)
        self.update_adjust_text = QtWidgets.QLabel("    Update adjustment:", self)
        self.update_not_needed_icon = QtGui.QPixmap(':/icons/ico3.png')
        self.update_adjust_icon = QtGui.QPixmap(':/icons/ico2.png')
        self.update_deltas_icon = QtGui.QPixmap(':/icons/ico1.png')
        self.label_adjust_update_required = QtWidgets.QLabel()
        self.label_deltas_update_required = QtWidgets.QLabel()

        self.statusBar().addPermanentWidget(self.update_deltas_text)
        self.statusBar().addPermanentWidget(self.label_deltas_update_required)
        self.statusBar().addPermanentWidget(self.update_adjust_text)
        self.statusBar().addPermanentWidget(self.label_adjust_update_required)

        # Enabling these will show status indicators on startup. Leaving them out to avoid confusion; they will be
        # set appropriately later
        # self.adjust_update_required()
        # self.deltas_update_required()

        # Right-click tree view context menu
        self.menus.mnDeleteSurvey = self.menus.create_action('Delete survey', slot=self.delete_survey)
        self.menus.mnDeleteLoop = self.menus.create_action('Delete loop', slot=self.delete_loop)
        self.menus.mnLoopProperties = self.menus.create_action('Loop properties', slot=self.properties_loop)
        self.menus.mnStationRename = self.menus.create_action('Rename station', slot=self.rename_station)
        self.menus.mnStationDelete = self.menus.create_action('Delete station(s)', slot=self.delete_station)
        self.menus.mnStationDuplicate = self.menus.create_action('Duplicate station', slot=self.duplicate_station)
        self.menus.mnDataNewLoop = self.menus.create_action('Move stations to new loop', slot=self.new_loop)
        self.menus.mnLoopAnimate = self.menus.create_action('Animate loop', slot=self.animate_loop)

        # self.resize(600,800)
        self.update_menus()
        self.path_install = os.getcwd()
        self.menus.set_state(MENU_STATE.UNINIT)

    def init_gui(self):
        """
        Called after loading a data file.
        """
        # Left panel: tree with data hierarchy (surveys, loops, stations)
        self.obsTreeModel.setHorizontalHeaderLabels(['Name', 'Date', 'g (\u00b5Gal)'])

        # Enable menus
        self.menus.set_state(MENU_STATE.INIT)

        # Resize, expand tree view
        self.gui_data_treeview.setModel(self.obsTreeModel)
        self.obsTreeModel.dataChanged.connect(self.on_obs_checked_change)
        # self.obsTreeModel.signal_refresh_view.connect(self.refresh_tables)
        self.obsTreeModel.signal_name_changed.connect(self.deltas_update_required)
        self.obsTreeModel.signal_delta_update_required.connect(self.deltas_update_required)
        self.selection_model = self.gui_data_treeview.selectionModel()
        self.selection_model.selectionChanged.connect(self.on_obs_tree_change)
        # self.data_treeview.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)

        self.gui_data_treeview.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)
        self.gui_data_treeview.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
        self.gui_data_treeview.customContextMenuRequested.connect(self.treeview_context_menu)
        self.gui_data_treeview.setItemDelegate(BoldDelegate(self))
        self.gui_data_treeview.doubleClicked.connect(self.activate_survey_or_loop)
        self.gui_data_treeview.setObjectName('data')
        self.gui_data_treeview.setEditTriggers(QtWidgets.QTreeView.EditKeyPressed)
        self.gui_data_treeview.setExpandsOnDoubleClick(False)
        self.gui_data_treeview.expandAll()
        self.gui_data_treeview.resizeColumnToContents(0)
        self.gui_data_treeview.resizeColumnToContents(1)
        self.gui_data_treeview.resizeColumnToContents(2)

        # Highlight first tree-view item
        self.select_first_treeview_item()

        # Activate first tree view item
        self.activate_survey_or_loop(self.index_current_loop)
        self.activate_survey_or_loop(self.index_current_survey)
        self.label_adjust_update_required_set = False
        # Set data plot
        self.update_data_tab()
        # self.selmodel.select(station.index(), QtCore.QItemSelectionModel.SelectCurrent)
        self.gui_data_treeview.setFocus()

    def adjust_update_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required_set = True
        self.label_adjust_update_required.setPixmap(self.update_adjust_icon)
        self.label_adjust_update_required.setToolTip('Update network adjustment')
        self.set_window_title_asterisk()
        self.update_menus()

    def adjust_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required_set = False
        self.label_adjust_update_required.setPixmap(self.update_not_needed_icon)
        self.label_adjust_update_required.setToolTip('Network adjustment is up to date')

    def deltas_update_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required_set = True
        self.label_deltas_update_required.setPixmap(self.update_deltas_icon)
        self.label_deltas_update_required.setToolTip('Update delta table')
        self.set_window_title_asterisk()
        self.update_menus()

    def deltas_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required_set = False
        self.label_deltas_update_required.setPixmap(self.update_not_needed_icon)
        self.label_deltas_update_required.setToolTip('Delta table is up to date')

    def select_first_treeview_item(self):
        """
        Selects the first item in the treeview
        """
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
        obstreeloop = obstreesurvey.child(0)
        station = obstreeloop.child(0)

        self.index_current_survey = obstreesurvey.index()
        self.index_current_loop = obstreeloop.index()
        self.index_current_loop_survey = obstreesurvey.index()
        self.index_current_station_loop = obstreeloop.index()
        self.index_current_station_survey = obstreesurvey.index()
        self.index_current_station = station.index()

    def tab_changed(self, new_idx):
        """
        Updates tab plots/tables as needed. These typically aren't updated unless they're visible.
        :param new_idx: Index of newly-selected tab.
        """
        if self.obsTreeModel.rowCount() > 0:
            if new_idx == 0:
                if self.index_current_station is not None:
                    self.update_data_tab()
            if new_idx == 1:
                if self.index_current_loop is not None:
                    self.update_drift_tables_and_plots()

    def update_data_tab(self):
        """
        Get station to plot, update station table model if necessary.
        """
        # Center panel: table (station values)
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreeloop = obstreestation.parent()
        station = obstreestation
        if obstreeloop.meter_type == 'CG5' \
                or obstreeloop.meter_type == 'Scintrex' \
                or obstreeloop.meter_type == 'CG6' \
                or obstreeloop.meter_type == 'csv' \
                or obstreeloop.meter_type == 'CG6Tsoft':
            self.station_model = ScintrexTableModel(station)
        elif obstreeloop.meter_type == 'Burris':
            self.station_model = BurrisTableModel(station)
        self.station_model.dataChanged.connect(self.update_data_tab)
        self.station_model.signal_update_coordinates.connect(self.populate_station_coords)
        self.station_model.signal_adjust_update_required.connect(self.adjust_update_required)
        self.station_model.signal_uncheck_station.connect(self.uncheck_station)
        self.station_model.signal_check_station.connect(self.check_station)
        self.tab_data.data_view.setModel(self.station_model)
        self.index_current_station_loop = obstreeloop.index()
        self.index_current_station_survey = obstreeloop.parent().index()
        self.obsTreeModel.dataChanged.emit(QtCore.QModelIndex(), QtCore.QModelIndex())
        self.tab_data.update_station_plot(station, obstreeloop.meter_type)

    def uncheck_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(0)

    def check_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(2)

    ###########################################################################
    # Load/Open/Save routines
    ###########################################################################
    def open_file_dialog(self, open_type):
        """
        Called from menus.py functions
        Parameters
        ----------
        open_type

        Returns
        -------

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(caption='Open file', directory=self.settings.value('current_dir'))

        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            if fname[-2:] == '.p' or fname[-4:] == '.gsa':
                self.msg = show_message('Please use "Open workspace... " to load a .p or .gsa file', 'File load error')
                return
            self.open_raw_data(fname, open_type)

    def open_raw_data(self, fname, open_type):
        """
        - Display a file opening window
        - Populate obsTreeModel
        :param open_type: 'choose' - Choose meter-style data format
                          'loop' - if appending loop to survey, otherwise assume appending survey to campaign
                          (can be both choose and loop, e.g. 'chooseloop')
                          'CG-6', 'Burris', or 'CG-5' - reading a raw data file, no appending
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # open file
        append_loop = True if open_type == 'loop' else False

        # When "append survey' or 'append loop' is called: accommodate the rare instance of combining meter
        # types on a single survey
        if open_type == 'loop' or open_type == 'survey':
            meter_type_dialog = DialogMeterType()
            test = meter_type_dialog.exec_()
            if test < 5:  # 5 = cancel  (accept/reject not working?)
                meter_type = meter_type_dialog.meter_type
            else:
                return
        else:
            meter_type = open_type
            if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
                overwrite_tree_dialog = DialogOverwrite()
                if overwrite_tree_dialog.exec_():
                    self.workspace_clear(confirm=False)
                else:
                    return

        if fname:
            self.path_output = os.path.dirname(fname)
            logging.info('Loading data file: %s', fname)

            # populate a Campaign object
            e = None
            try:
                self.all_survey_data = self.read_raw_data_file(fname, meter_type)
                if append_loop:
                    obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
                    # Loads all survey data into a single loop.
                    obstreesurvey.populate(self.all_survey_data, name=str(obstreesurvey.loop_count),
                                           source=os.path.basename(fname))
                else:
                    obstreesurvey = ObsTreeSurvey(str(num2date(self.all_survey_data.t[0]).date()))
                    obstreesurvey.populate(self.all_survey_data, source=os.path.basename(fname))
                    self.obsTreeModel.appendRow([obstreesurvey, QtGui.QStandardItem('a'), QtGui.QStandardItem('a')])
            except IOError as err:
                e = err
                self.msg = show_message('No file : {}'.format(fname), 'File error')
            except (IndexError, ValueError) as err:
                stream = QtCore.QFile(":/text/err_{}.txt".format(meter_type))
                stream.open(QtCore.QIODevice.ReadOnly)
                text = QtCore.QTextStream(stream).readAll()
                stream.close()
                if hasattr(err, 'i') and hasattr(err, 'line'):
                    help_message = text.format(err.i, err.line)
                    self.msg = show_message('Error reading file at line {:d}'.
                                            format(err.i), 'File error', helptext=help_message)
                else:
                    help_message = text.format("NA", "NA")
                    self.msg = show_message('Error reading file',
                                            'File error', helptext=help_message)
                e = err
            if e:
                logging.exception(e, exc_info=True)
                return False

            if self.obsTreeModel.rowCount() > 0:
                self.init_gui()
                if open_type is not 'CG5':
                    self.populate_station_coords()
                self.workspace_loaded = True
                QtWidgets.QApplication.restoreOverrideCursor()
                self.set_window_title_asterisk()
                QtWidgets.QApplication.processEvents()
                self.update_menus()
            else:
                QtWidgets.QApplication.restoreOverrideCursor()
                self.msg = show_message('Unknown import error', 'File error')
        else:
            QtWidgets.QApplication.restoreOverrideCursor()
            return False

    @staticmethod
    def read_raw_data_file(filename, meter_type):
        """
        Read raw relative-gravity text file in the format exported from meter (Scintrex or Burris). Data are returned to
        the calling function.
        :param filename: Full path to import file
        :param meter_type: 'Burris', 'CG-5', 'CG-6'
        :return all_survey_data: ChannelList object with all survey data
        """
        try:
            all_survey_data = ChannelList()
            with open(filename, 'r') as fh:
                logging.info("number of lines: {:d}".format(len([1 for line in open(filename, 'r')])))
                all_survey_data.meter_type = meter_type
                if meter_type == 'csv':
                    _ = fh.readline()
                    all_survey_data = read_csv(fh)
                elif meter_type == 'CG5':
                    all_survey_data = read_cg5(fh)
                elif meter_type == 'Burris':
                    all_survey_data = read_burris(fh)
                elif meter_type == 'CG6':
                    all_survey_data = read_cg6(fh)
                elif meter_type == 'CG6Tsoft':
                    all_survey_data = read_cg6tsoft(fh)

                return all_survey_data

        # Returning e like this allows exceptions to be tested in pytest
        except IOError:
            raise
        except ValueError as e:
            raise e
        except IndexError as e:
            raise e

    def workspace_append(self):
        """
        Append previously-saved workspace to current workspace.
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.settings.value('current_dir'))
        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            if fname[-1] is 'p':
                self.msg = show_message('If trying to append a .p file, please save it as a .gsa file first.',
                                        'Import error')
                return
            obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(fname)
            # TODO: Do something with coords (append to table if not already there)
            for survey in obstreesurveys:
                self.obsTreeModel.appendRow([survey,
                                             QtGui.QStandardItem('0'),
                                             QtGui.QStandardItem('0')])
            self.update_all_drift_plots()
            self.populate_station_coords()
            self.workspace_loaded = True
            self.populate_survey_deltatable_from_simpledeltas(delta_models, obstreesurveys)
            QtWidgets.QApplication.restoreOverrideCursor()
            self.set_window_title_asterisk()
            self.update_menus()

    def workspace_clear(self, confirm=True):
        """
        Clears all models and refreshes view.
        """
        if confirm:
            if self.windowTitle()[-1] == '*':
                quit_msg = "The workspace isn't saved. Are you sure you want to clear all data?"
                reply = QtWidgets.QMessageBox.question(self, 'Message',
                                                       quit_msg, QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.No:
                    return

        logging.info("Workspace cleared")
        self.obsTreeModel = ObsTreeModel()
        self.gui_data_treeview.setModel(None)
        self.gui_data_treeview.update()
        self.tab_data.clear_axes()
        self.tab_data.data_view.setModel(None)
        self.tab_data.data_view.update()
        self.tab_drift.delta_view.setModel(None)
        self.tab_drift.delta_view.update()
        self.tab_drift.dg_samples_view.setModel(None)
        self.tab_drift.dg_samples_view.update()
        self.tab_drift.clear_axes()
        self.tab_drift.drift_plot_weighted.setCheckState(0)
        self.tab_drift.drift_cont_startendcombobox.setCurrentIndex(0)
        self.tab_drift.drift_polydegree_combobox.setCurrentIndex(0)
        self.tab_drift.driftmethod_combobox.setCurrentIndex(0)
        self.tab_drift.tension_slider.setValue(1250)
        self.tab_adjust.delta_view.setModel(None)
        self.tab_adjust.delta_view.update()
        self.tab_adjust.datum_view.setModel(None)
        self.tab_adjust.datum_view.update()
        self.tab_adjust.results_view.setModel(None)
        self.tab_adjust.results_view.update()
        self.tab_adjust.stats_view.setModel(None)
        self.tab_adjust.stats_view.update()
        self.setWindowTitle('GSadjust')
        self.update_menus()


    def workspace_save(self):
        """
        Saves data if a workspace has already been saved
        """
        if self.label_deltas_update_required_set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network '
                'Adjustment tab is not up to date.', 'Workspace save error'
            )
            return
        fname = self.obsTreeModel.save_workspace(self.workspace_savename)
        if not fname:
            self.msg = show_message("Workspace save error", "Error")
            return

        self.msg = show_message('Workspace saved', 'GSadjust', icon=QtWidgets.QMessageBox.Information)
        self.set_window_title(fname)
        return True

    def workspace_save_as(self):
        """
        Saves data object using json.dump()
        """
        if self.label_deltas_update_required_set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network '
                'Adjustment tab is not up to date.', 'Workspace save error'
            )
            return

        fname, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Save workspace as', self.settings.value('current_dir'))
        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            try:
                save_name = self.obsTreeModel.save_workspace(fname)
            except Exception as e:
                self.msg = show_message("Workspace save error", "Error")
                logging.exception(e, exc_info=True)
                self.menus.mnFileSaveWorkspace.setEnabled(False)
                return

            if not save_name:
                self.msg = show_message("Workspace save error", "Error")
                return

            self.set_window_title(fname)
            self.msg = show_message('Workspace saved', 'GSadjust', icon=QtWidgets.QMessageBox.Information)
            self.workspace_savename = fname
            self.update_menus()

    def workspace_open_getfile(self):
        """
        Gets filename to open and asks whether to  append or overwrite, if applicable.
        :return:
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.settings.value('current_dir'))

        if not fname or fname[-2:] != '.p':
            self.msg = show_message(
                'Saved workspaces should have a .p or .gsa extension. '
                'Please use "Open workspace..." to load a .gsa file, or '
                '"Open raw...data" to load a data file.', 'File load error'
            )
            return

        self.settings.setValue('current_dir', os.path.dirname(fname))
        if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
            overwrite_tree_dialog = DialogOverwrite()
            if overwrite_tree_dialog.exec_():
                self.workspace_clear()
                self.workspace_open(fname)
            else:
                return
        else:
            self.workspace_open(fname)

    def workspace_open_getjson(self):
        """
        Gets filename to open and asks whether to  append or overwrite, if applicable.
        :return:
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open File', self.settings.value('current_dir'))
        if not fname:
            return
        elif fname[-4:] != '.gsa':
            self.msg = show_message(
                'Saved workspaces should have a .gsa extension. '
                'Please use "Open raw...data" to load a data file'
                ' or "Open workspace (.p format)" to open a workspace'
                ' with .p extension.', 'File load error'
            )
            return

        self.settings.setValue('current_dir', os.path.dirname(fname))
        if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
            overwrite_tree_dialog = DialogOverwrite()
            if overwrite_tree_dialog.exec_():
                self.workspace_clear()
                self.workspace_open_json(fname)
            else:
                return
        else:
            self.workspace_open_json(fname)

    def workspace_open_json(self, fname):
        """
        Loads data from JSON file. Restores PyQt tables to Survey object
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Returns list of survey delta tables so they can be passed to populate_survey_deltatable_from_simpledeltas()
        # try:
        QtWidgets.QApplication.processEvents()
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(fname)
        if obstreesurveys:
            self.workspace_savename = fname
            self.populate_obstreemodel(obstreesurveys, delta_models)
            self.adjust_update_required()
            self.set_window_title(fname)
        if coords:
            self.obsTreeModel.station_coords = coords
        self.update_menus()

    def workspace_open(self, fname):
        """
        Loads data from pickle file. Restores PyQt tables to Survey object (PyQt tables can't be
        pickled and are removed in workspace_save).
        DEPRECATED, WILL REMOVE EVENTUALLY (REPLACED WITH JSON)
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Returns list of survey delta tables so they can be passed to populate_survey_deltatable_from_simpledeltas()
        # try:
        QtWidgets.QApplication.processEvents()
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace_p(fname)
        if obstreesurveys:
            self.workspace_savename = fname
            self.populate_obstreemodel(obstreesurveys, delta_models)
            self.set_window_title(fname)
        if coords:
            self.obsTreeModel.station_coords = coords
        self.update_menus()

    def populate_obstreemodel(self, obstreesurveys, delta_models):
        """
        Only called for loading workspace, not when loading raw data.
        Parameters
        ----------
        obstreesurveys
        delta_models

        Returns
        -------

        """
        pbar = QtWidgets.QProgressDialog(labelText='Loading workspace', minimum=0, maximum=4)
        pbar.setWindowTitle('GSadjust')
        pbar.setLabelText('Building Observation Tree')
        pbar.show()
        for survey in obstreesurveys:
            self.obsTreeModel.appendRow([survey,
                                         QtGui.QStandardItem('0'),
                                         QtGui.QStandardItem('0')])
        pbar.setLabelText('Building Observation Tree')
        QtWidgets.QApplication.processEvents()
        if not delta_models:
            QtWidgets.QApplication.restoreOverrideCursor()
            return
        else:
            i = 0
            firststation = None
            # This avoids an error when the first loop (or subsequent loops) are empty
            firstsurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
            while firststation is None:
                firstloop = firstsurvey.child(i)
                firststation = firstloop.child(0)
                i += 1
            pbar.setValue(1)
            pbar.setLabelText('Updating drift plots')
            QtWidgets.QApplication.processEvents()
            self.index_current_survey = firstsurvey.index()
            self.index_current_loop = firstloop.index()
            self.index_current_station = firststation.index()
            self.index_current_loop_survey = firstsurvey.index()
            self.index_current_station_loop = firstloop.index()
            self.index_current_station_survey = firstsurvey.index()
            try:
                self.populate_station_coords()
            except Exception as e:
                # sometimes coordinates aren't valid
                pass

            self.workspace_loaded = True
            self.update_all_drift_plots()
            pbar.setValue(2)
            pbar.setLabelText('Populating delta tables')
            QtWidgets.QApplication.processEvents()
            # The deltas on the survey delta table (on the network adjustment tab) aren't saved. When loading a
            # workspace, the loop deltas first have to be created by update_all_drift_plots(), then the survey delta
            # table can be updated.
            self.populate_survey_deltatable_from_simpledeltas(delta_models, obstreesurveys)
            # for survey in obstreesurveys:
            #     self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

            self.update_adjust_tables()
            pbar.setValue(3)
            pbar.setLabelText('Initializing GUI')
            QtWidgets.QApplication.processEvents()
            self.init_gui()
            self.deltas_update_not_required()
            QtWidgets.QApplication.restoreOverrideCursor()
            pbar.setValue(4)
            pbar.close()

    def populate_survey_deltatable_from_simpledeltas(self, delta_models, surveys):
        """
        When workspaces are saved/loaded as json (.gsa files), there are 2 sets of deltas: those based on the data (
        drift-tab deltas), and those that might have edits (network-adjustment-tab deltas). The former we don't bother
        saving, the latter we do save. Deltas from the net adj tab are in turn based on other deltas (Roman method),
        and/or from stations directly ('normal' deltas). This function recreates the scheme from saved json by
        matching up stations with deltas and deltas with deltas.
        Parameters
        ----------
        delta_models: Python lists of deltas read from JSON file, one entry per survey
        surveys: List of ObsTreeSurvey objects

        Returns
        -------

        """
        deltas = self.obsTreeModel.deltas()
        for idx, delta_model in enumerate(delta_models):  # One delta_model per survey
            for simpledelta in delta_model:
                if not hasattr(simpledelta, 'loop'):
                    simpledelta.loop = None
                i = 0
                try:
                    if simpledelta.type == 'normal':
                        try:
                            if not type(simpledelta) == Delta:  # Should be SimpleNamespace
                                # Lookup station based on hash
                                station1 = surveys[idx].return_obstreestation(simpledelta.sta1)
                                station2 = surveys[idx].return_obstreestation(simpledelta.sta2)
                                if station1 is not None and station2 is not None:
                                    d = Delta(station1, station2,
                                              adj_sd=simpledelta.adj_sd,
                                              driftcorr=simpledelta.driftcorr,
                                              ls_drift=simpledelta.ls_drift,
                                              delta_type=simpledelta.type,
                                              checked=simpledelta.checked,
                                              loop=simpledelta.loop)
                            # For dealing with old-style .p workspaces
                            elif type(simpledelta) == Delta:
                                d = simpledelta
                        except NameError:
                            logging.error('Delta re-creation error')
                    elif simpledelta.type == 'list':
                        if not hasattr(simpledelta, 'key'):
                            list_of_deltas = []
                            for delta in simpledelta.sta2:
                                station1 = surveys[idx].return_obstreestation(delta[0])
                                station2 = (surveys[idx].return_obstreestation(delta[1]),
                                            surveys[idx].return_obstreestation(delta[2]))
                                tpd = Delta(station1, station2,
                                            adj_sd=simpledelta.adj_sd,
                                            driftcorr=simpledelta.driftcorr,
                                            ls_drift=simpledelta.ls_drift,
                                            delta_type='three_point',
                                            checked=simpledelta.checked,
                                            loop=simpledelta.loop)
                                list_of_deltas.append(tpd)
                            d = Delta.from_list(list_of_deltas)
                            if simpledelta.adj_sd < 998:
                                d.adj_sd = simpledelta.adj_sd
                            # for sg, the 'list'-type delta returns the mean of all dg's, the user can't check/uncheck
                            # individual dg's. Therefore setting the check state when creating the three-point delta
                            # ("tpd", above) is meaningless. What we want to do is set the check state of the list
                            # delta.
                            d.checked = simpledelta.checked
                        # This section is necessary to load older .p versions. It's much slower than the above section.
                        else:
                            try:
                                d = return_delta_given_key(simpledelta.key, deltas)
                            except:
                                return
                    elif simpledelta.type == 'assigned':
                        station1 = surveys[idx].return_obstreestation(simpledelta.sta1)
                        station2 = surveys[idx].return_obstreestation(simpledelta.sta2)
                        d = Delta(station1, station2,
                                  adj_sd=simpledelta.adj_sd,
                                  driftcorr=simpledelta.driftcorr,
                                  ls_drift=simpledelta.ls_drift,
                                  delta_type=simpledelta.type,
                                  checked=simpledelta.checked,
                                  loop=simpledelta.loop)
                        d.assigned_dg = simpledelta.assigned_dg
                    if d:
                        i += 1
                        surveys[idx].delta_model.insertRows(d, 0)
                    else:  # unable to create delta
                        self.msg = show_message('Import error',
                                                'Error populating delta table. Please update delta '
                                                'table on Adjust tab', )
                except:
                    self.msg = show_message('Import error', 'Import error')

    def populate_station_coords(self):
        """
        Stores a single set of coordinates for each station with the obsTreeModel object. The coordinates of the last
        Station in the Survey > Loop > Station hierarchy are used.

        Used as a slot for the self.station_model.signal_update_coordinates signal (thus init_station_coords can't
        be called directly)
        """
        self.obsTreeModel.station_coords = init_station_coords_dict(self.obsTreeModel)

    ###########################################################################
    # General routines
    ###########################################################################
    def populate_deltamodel(self, populate_type):
        """
        Called from menu item
        :param populate_type: 'all', 'selectedLoop', or 'selectedSurvey'
        """
        table_updated = False

        if populate_type == 'all':
            self.update_all_drift_plots()
            for survey in self.obsTreeModel.checked_surveys():
                table_updated = survey.populate_delta_model(clear=True)
                self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

            # item = self.obsTreeModel.invisibleRootItem()
        elif populate_type == 'selectedsurvey':
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            self.update_survey_drift_plots(survey)
            table_updated = survey.populate_delta_model(clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        elif populate_type == 'selectedloop':
            selected_idx = self.gui_data_treeview.selectedIndexes()
            # There may be one, or multiple loops selected. If only one is selected, we'll populate the delta table
            # based on the currentLoopIndex (which will be in bold but not necessarily highlighted).
            if len(selected_idx) >= 4:
                selected_items = []
                for i in selected_idx:
                    selected_items.append(self.obsTreeModel.itemFromIndex(i))
                # selected_items will contain 3 entries for every tree view item (one for the name, plus 2 for
                # g and std. dev. First, decimate to just the name entries
                selected_items = selected_items[::3]
                loops = [item for item in selected_items if type(item) == ObsTreeLoop]
                first = True
                for loop in loops:
                    self.update_loop_drift_plots(loop)
                    survey = loop.parent()
                    if first:
                        table_updated = survey.populate_delta_model(loop, clear=True)
                        first = False
                    else:
                        table_updated = survey.populate_delta_model(loop, clear=False)
            else:
                loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
                survey = loop.parent()
                table_updated = survey.populate_delta_model(loop, clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        if table_updated:
            self.deltas_update_not_required()
            self.adjust_update_required()
            self.update_adjust_tables()
            self.tab_adjust.delta_proxy_model.sort(3)
        self.menus.set_state(MENU_STATE.DELTA_MODEL)

    def activate_survey_or_loop(self, index):
        """
        Highlights active survey or loop in tree view.
        :param index: PyQt index of newly-highlighted tree item, sent by doubleClicked event
        """
        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        item = self.obsTreeModel.itemFromIndex(index)
        try:
            # If a loop:
            if type(item) is ObsTreeLoop:
                if self.previous_loop is not None:
                    self.previous_loop.fontweight = QtGui.QFont.Normal
                    self.previous_loop.cellcolor = QtCore.Qt.white
                self.previous_loop = item
                item.cellcolor = QtCore.Qt.lightGray
                item.fontweight = QtGui.QFont.Bold
                self.index_current_loop = index
                if self.tab_widget.currentIndex() == 1:
                    self.update_drift_tables_and_plots()

            # If a survey
            elif type(item) is ObsTreeSurvey:
                if self.previous_survey is not None:
                    self.previous_survey.fontweight = QtGui.QFont.Normal
                self.previous_survey = item
                self.index_current_survey = index
                item.fontweight = QtGui.QFont.Bold
                self.update_adjust_tables()
        except Exception as e:
            logging.exception(e, exc_info=True)

        self.obsTreeModel.layoutChanged.emit()

        QtWidgets.QApplication.restoreOverrideCursor()

    def set_window_title(self, fname):
        self.setWindowTitle('GSadjust - ' + fname)

    def set_window_title_asterisk(self):
        title = self.windowTitle()
        last_char = title[-1]
        if last_char != '*':
            title += '*'
        self.setWindowTitle(title)

    def update_menus(self):
        """
        Set enabled/disabled states for menus.
        """
        if self.workspace_savename and self.windowTitle()[-1] == '*':
            self.menus.set_state(MENU_STATE.ACTIVE_WORKSPACE)
        else:
            self.menus.set_state(MENU_STATE.NO_ACTIVE_WORKSPACE)
        if self.obsTreeModel.rowCount() >= 1:
            self.menus.set_state(MENU_STATE.AT_LEAST_ONE_SURVEY)
            if self.obsTreeModel.invisibleRootItem().rowCount() > 1:
                self.menus.set_state(MENU_STATE.MORE_THAN_ONE_SURVEY)
                if not self.label_adjust_update_required_set:
                    self.menus.set_state(MENU_STATE.CALCULATE_CHANGE)
            try:
                current_survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
                if current_survey.delta_model.rowCount() > 0:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_DELTAS)
                else:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_NO_DELTAS)
                if current_survey.results_model.rowCount() > 0 and not self.label_adjust_update_required_set:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_RESULTS)
                else:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_NO_RESULTS)
            except TypeError:
                # catches during PyTest
                return
            except AttributeError:
                # catches if no delta_model
                self.menus.set_state(MENU_STATE.UNINIT)
        else:
            self.menus.set_state(MENU_STATE.UNINIT)

        QtWidgets.QApplication.restoreOverrideCursor()

    def update_all_drift_plots(self):
        """
        Updates drift_tab plots and delta_models, even if not in view.
        """
        orig_loop_index = self.index_current_loop
        for survey in self.obsTreeModel.surveys():
            self.update_survey_drift_plots(survey)
        self.index_current_loop = orig_loop_index

    def update_survey_drift_plots(self, survey):
        for loop in survey.loops():
            self.update_loop_drift_plots(loop)

    def update_loop_drift_plots(self, loop):
        self.index_current_loop = loop.index()
        self.update_drift_tables_and_plots(update=False)

    def show_delta_update_message(self):
        self.msg = show_message('The Delta-g value can only be edited if the drift-correction method for the '
                                'respective loop is a method other than the Roman method.',
                                'Delta error')

    def update_adjust_tables(self):
        """
        Update delta-g and datum tables after selecting a new survey in the tree view, or after a network adjustment
        """

        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)

        survey.delta_model.layoutAboutToBeChanged.emit()
        survey.datum_model.layoutAboutToBeChanged.emit()
        survey.results_model.layoutAboutToBeChanged.emit()

        try:
            survey.delta_model.signal_adjust_update_required.connect(self.adjust_update_required)
            survey.delta_model.tried_to_update_list_delta.connect(self.show_delta_update_message)
            survey.datum_model.signal_adjust_update_required.connect(self.adjust_update_required)
            self.tab_adjust.delta_proxy_model.setSourceModel(survey.delta_model)
            self.tab_adjust.datum_proxy_model.setSourceModel(survey.datum_model)
            self.tab_adjust.results_proxy_model.setSourceModel(survey.results_model)
        except:
            pass
        self.tab_adjust.delta_proxy_model.invalidate()
        self.tab_adjust.datum_proxy_model.invalidate()
        self.tab_adjust.results_proxy_model.invalidate()
        self.tab_adjust.results_view.setModel(self.tab_adjust.results_proxy_model)
        self.tab_adjust.results_view.setSortingEnabled(True)
        self.tab_adjust.delta_view.setModel(self.tab_adjust.delta_proxy_model)
        self.tab_adjust.datum_view.setModel(self.tab_adjust.datum_proxy_model)
        stats_model = QtGui.QStandardItemModel()
        if survey.adjustment.adjustmentresults.n_unknowns > 0:  # Numpy adjustment

            for line in survey.adjustment.results_string():
                try:
                    line_elems = line.split(':')
                    if len(line_elems) == 2:  # normal line, stat: value
                        stats_model.appendRow([QtGui.QStandardItem(line_elems[0]),
                                               QtGui.QStandardItem(line_elems[1].strip())])
                    else:  # Chi test accepted or rejected. No ":"
                        text = line_elems[0].strip()
                        qt_item = QtGui.QStandardItem(text)
                        if 'rejected' in text:
                            qt_item.setForeground(QtCore.Qt.red)
                        stats_model.appendRow([qt_item, QtGui.QStandardItem('')])
                except:
                    pass
        elif survey.adjustment.adjustmentresults.text:  # Gravnet adjustment
            self.tab_adjust.stats_view.setColumnWidth(0, 600)
            stats_model.setColumnCount(1)
            stats_model.setHorizontalHeaderLabels([''])
            for line in survey.adjustment.adjustmentresults.text:
                stats_model.appendRow([QtGui.QStandardItem(line)])
        self.tab_adjust.stats_view.setModel(stats_model)
        stats_model.setColumnCount(2)
        stats_model.setHorizontalHeaderLabels(['', ''])
        self.tab_adjust.stats_view.setColumnWidth(0, 250)
        self.tab_adjust.stats_view.setColumnWidth(1, 150)
        self.tab_adjust.update_col_widths()

    def update_drift_tables_and_plots(self, update=True):
        """
        First updates the drift_method combobox, then calls set_drift_method to update plots.
        :param update: Plots are only updated if True. Saves time when loading a workspace.
        """

        drift_method = self.obsTreeModel.itemFromIndex(self.index_current_loop).drift_method
        self.tab_drift.driftmethod_combobox.setCurrentIndex(self.drift_lookup[drift_method])
        self.tab_drift.set_drift_method(update)

    def on_obs_checked_change(self, selected):
        """
        Called when a checkbox state is changed, but not when a new item selected. Should update drift plots
        if on drift tab, but otherwise do nothing.
        :param selected: Selected indexes
        """
        if selected.model() is not None:
            self.deltas_update_required()
            self.adjust_update_required()
            if self.tab_widget.currentIndex() == 0:
                self.update_drift_tables_and_plots(update=False)
            elif self.tab_widget.currentIndex() == 1:
                self.update_drift_tables_and_plots(update=True)
            elif self.tab_widget.currentIndex() == 2:
                self.update_drift_tables_and_plots(update=False)
                self.tab_adjust.delta_view.update()
                self.tab_adjust.delta_view.repaint()
        self.set_window_title_asterisk()
        self.update_menus()

    def on_obs_tree_change(self, selected):
        """
        Called when the selection model changes.
        :param selected: Selected indexes
        """
        indexes = selected.indexes()
        if indexes:
            item = self.obsTreeModel.itemFromIndex(indexes[0])
            if item:
                if type(item) is ObsTreeStation:
                    self.index_current_station = indexes[0]
                    if self.tab_widget.currentIndex() == 0:
                        self.update_data_tab()
                    if self.tab_widget.currentIndex() == 1:
                        self.update_drift_tables_and_plots()

    def adjusted_vs_observed_datum_analysis(self):
        return

    def correction_ocean_loading(self):
        self.msg = show_message('Not implemented', 'Error')

    def correction_atmospheric(self):
        self.msg = show_message('Not implemented', 'Error')

    def correct_recorded_time(self):
        """
        Correct all times from an offset: when GMT time entered in relative gravimeter is bad.
        """
        # ask for time difference to apply

        text, ok = QtWidgets.QInputDialog.getText(self, 'Input parameters',
                                                  'time offset to apply (min)?')
        if ok:
            time_correction_dialog = DialogApplyTimeCorrection()
            time_correction_dialog.msg.exec_()
            correction_type = time_correction_dialog.time_correction_type
            if correction_type:
                time_correction(self.obsTreeModel, int(text), self.index_current_survey, self.index_current_loop,
                                self.gui_data_treeview.selectedIndexes())
                self.set_window_title_asterisk()

    def set_vertical_gradient_interval(self):
        """
        Dialog that queries user for the distance over which vertical gradient is measured.
        """
        interval = VerticalGradientDialog(self.vertical_gradient_interval)
        self.vertical_gradient_interval = interval

    def vertical_gradient_write(self):
        """
        Writes a .grd file with two values: gradient and standard deviation. Only works when Roman drift method
        is used.
        """
        deltamodel = self.tab_drift.delta_view.model()
        if deltamodel.rowCount() == 1:
            stationname = self.obsTreeModel.itemFromIndex(self.index_current_loop).child(0).name
            defaultfile = os.path.join(self.settings.value('current_dir'), stationname + '.grd')
            file_name, _ = QtWidgets.QFileDialog.getSaveFileName(None, 'Vertical gradient file to write',
                                                                 defaultfile)
            if file_name:
                delta = deltamodel.data(deltamodel.index(0, 0), role=QtCore.Qt.UserRole)
                with open(file_name, 'w') as fid:
                    fid.write('{:0.2f}'.format(-1 * delta.dg / self.vertical_gradient_interval))
                    fid.write(' +/- {:0.2f}'.format(delta.sd / self.vertical_gradient_interval))
        else:
            self.msg = show_message("Incorrect number of delta-g's (should be 1; try the Roman method)",
                                    "Vertical gradient error")

    def add_tare(self):
        """
        Opens a dialog to add tare to loop tare_model.
        """
        new_tare_date, new_tare_value = 0, 0
        current_loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        obstreestation = current_loop.child(0)
        default_time = num2date(obstreestation.t[0])
        taredialog = AddTareDialog(default_time)
        if taredialog.exec_():
            new_tare_date = taredialog.dt_edit.dateTime()
            new_tare_value = taredialog.edit_box.text()
        try:
            tare = Tare(new_tare_date.date(), new_tare_date.time(), new_tare_value)
        except:
            return
        if not hasattr(current_loop, 'tare_model'):
            current_loop.tare_model = TareTableModel
        current_loop.tare_model.insertRows(tare)
        self.tab_drift.process_tares(current_loop)
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def clear_delta_model(self):
        """
        Remove all deltas from survey delta model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).delta_model.clearDeltas()
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.clear_adjustment_text()
        self.deltas_update_required()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_adjustment_text(self):
        self.tab_adjust.stats_view.setModel(None)
        self.tab_adjust.stats_view.update()
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        survey.adjustment.adjustmentresults.text = []
        survey.adjustment.adjustmentresults.n_unknowns = 0

    def clear_datum_model(self):
        """
        Remove all datums from datum model shown on network adjustment tab.
        :return:
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.clearDatums()
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.clear_adjustment_text()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_results_model(self):
        """
        Remove all results from results model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(self.index_current_survey).results_model.clearResults()
        self.update_adjust_tables()

    def animate_loop(self):
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        coords = self.obsTreeModel.station_coords
        if not coords:
            self.msg = show_message('No station coordinates', 'GSadjust error')
        else:
            lat, lon, dates = [], [], []
            try:
                for station in loop.checked_stations():
                    lat.append(coords[station.station_name][1])
                    lon.append(coords[station.station_name][0])
                    dates.append(station.tmean())
                plt = PlotLoopAnimation([lat, lon, dates])
                plt.show()
            except:
                self.msg = show_message('Unknown error', 'GSadjust error')


    def properties_loop(self):
        """
        Show popup dialog to specify loop properties.
        :return:
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        loops = []
        for idx in indexes:
            if idx.column() == 0:
                loops.append(self.obsTreeModel.itemFromIndex(idx))
        loop_options = DialogLoopProperties(loops, parent=self)
        if loop_options.exec_():
            # Sync new meter numbers with station objects
            # for loop in self.loops:

            for loop in loops:
                loop.oper = loop_options.operator_edit.text()
                loop.meter = loop_options.meter_edit.text()
                loop.comment = loop_options.comment_edit.toPlainText()
                for i in range(loop.rowCount()):
                    obstreestation = loop.child(i)
                    obstreestation.meter = [loop.meter] * len(obstreestation.meter)
                    obstreestation.oper = [loop.oper] * len(obstreestation.oper)
            self.set_window_title_asterisk()
        self.update_data_tab()

    def delete_survey(self):
        """
        Remove loop or survey from tree view
        """
        # A little clunky. Setting self.index_current_survey earlier caused unhandled crashes
        index = self.gui_data_treeview.selectedIndexes()

        if index[0] == self.index_current_station_survey:
            update_selected_station = True
        else:
            update_selected_station = False

        if index[0] == self.index_current_survey:
            update_selected_survey = True
            old_row = index[0].row()
        else:
            update_selected_survey = False

        if len(self.obsTreeModel.surveys()) == 1:
            self.workspace_clear(confirm=False)
            self.update_menus()
            return

        self.obsTreeModel.beginRemoveRows(index[0].parent(), index[0].row(), index[0].row() + 1)
        self.obsTreeModel.removeRows(index[0].row(), 1, index[0].parent())
        self.obsTreeModel.endRemoveRows()

        if update_selected_survey:
            if old_row == 0:
                self.index_current_survey = self.obsTreeModel.index(0, 0)
            else:
                self.index_current_survey = self.obsTreeModel.index(old_row - 1, 0)
            if update_selected_station:
                obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
                first_loop = obstreesurvey.child(0)
                first_station = first_loop.child(0)
                self.index_current_station = first_station.index()
                self.update_data_tab()
        self.activate_survey_or_loop(self.index_current_survey)
        self.set_window_title_asterisk()
        self.update_menus()

    def delete_loop(self):
        """
        Remove loop or survey from tree view
        """
        index = self.gui_data_treeview.selectedIndexes()
        obstreesurvey = self.obsTreeModel.itemFromIndex(index[0]).parent()

        if index[0] == self.index_current_station_loop:
            update_selected_station = True
        else:
            update_selected_station = False

        if index[0] == self.index_current_loop:
            update_selected_loop = True
            old_row = index[0].row()
        else:
            update_selected_loop = False

        self.obsTreeModel.beginRemoveRows(index[0].parent(), index[0].row(), index[0].row() + 1)
        self.obsTreeModel.removeRows(index[0].row(), 1, index[0].parent())
        self.obsTreeModel.endRemoveRows()

        if obstreesurvey.rowCount() == 0:
            self.index_current_loop = None
            self.tab_drift.reset()
        else:
            if update_selected_loop:
                if old_row == 0:
                    loop = obstreesurvey.child(0)
                    self.index_current_loop = loop.index()
                else:
                    loop = obstreesurvey.child(old_row - 1)
                    self.index_current_loop = loop.index()
                if update_selected_station:
                    first_station = loop.child(0)
                    self.index_current_station = first_station.index()
                    self.update_data_tab()
                self.activate_survey_or_loop(self.index_current_loop)
        self.set_window_title_asterisk()
        self.update_menus()

    def rename_station(self):
        """
        Rename station; same as F2.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        if len(indexes) > 3 or len(indexes) == 0:
            return
        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        index = indexes[0]
        trigger = self.gui_data_treeview.EditKeyPressed
        event = None
        self.gui_data_treeview.edit(index, trigger, event)
        self.set_window_title_asterisk()

    def delete_station(self):
        """
        Remove station from tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()

        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        indexes = indexes[0::3]
        for index in reversed(indexes):
            self.obsTreeModel.removeRow(index.row(), index.parent())
            self.set_window_title_asterisk()
        if index.row() > 0:
            self.index_current_station = index.sibling(index.row() - 1, 0)
        else:
            self.index_current_station = index.sibling(0, 0)

        first_index = indexes[0]
        if first_index.row() > 0:
            row = first_index.row() - 1
        else:
            row = 0
        new_selection_index = self.obsTreeModel.index(row,
                                                      0,
                                                      first_index.parent())
        self.selection_model.select(new_selection_index, QtCore.QItemSelectionModel.SelectCurrent)
        self.update_data_tab()
        self.update_menus()

    def delete_tare(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_drift.tare_view.selectedIndexes()
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        for idx in reversed(index):
            loop.tare_model.removeRow(idx)
        self.tab_drift.tare_view.update()
        self.tab_drift.process_tares(self.obsTreeModel.itemFromIndex(self.index_current_loop))
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def delete_datum(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_adjust.datum_view.selectedIndexes()
        i = [self.tab_adjust.datum_proxy_model.mapToSource(idx) for idx in index]
        i.sort(key=lambda x: x.row(), reverse=True)
        for idx in i:
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            survey.datum_model.removeRow(idx)
        self.tab_adjust.datum_view.update()
        self.set_window_title_asterisk()

    def divide_by_time(self):
        # Prompt user to select time threshold
        loopdialog = LoopTimeThresholdDialog()
        if loopdialog.exec_():
            loop_thresh = loopdialog.dt_edit.dateTime()
            # Convert to days. Subtract one from the date because the default is 1 (i.e., if the time set in the
            # loop dialog is 8:00, loop thresh is a Qdatetime equal to (2000,1,1,8,0).
            loop_thresh = int(loop_thresh.toString("H")) / 24 + int(loop_thresh.toString("d")) - 1
        else:
            return
        self.divide_survey(loop_thresh)

    def divide_by_height(self):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a time interval, then scans the current
        loop and divides station occupations separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)

        if obstreeloop.rowCount() > 1:
            self.msg = show_message("Loop must have a single station to divide by height.", "GSadjust error")
            return

        station = obstreeloop.child(0)
        height = station.height[0]
        height_idx = 0
        n_samples = len(station.height)
        count_dict = dict()
        heights = set(station.height)
        for h in heights:
            count_dict[h] = 0
        for idx, h in enumerate(station.height):
            if h != height or idx == len(station.height) - 1:
                new_station = ChannelList()
                for k, v in station.__dict__.items():
                    try:  # some fields have no len()
                        if len(v) == n_samples:
                            # temp_sta = new_station.extract_subset_idx(height_idx, idx)
                            setattr(new_station, k, v[height_idx:idx])
                        else:
                            setattr(new_station, k, v)
                    except Exception:
                        continue

                # new_station = 0
                # # obstreestation = self.obsTreeModel.itemFromIndex(index)
                # new_station_count = float(obstreestation.station_count) + 0.1
                if height == 0:
                    name = station.station_name
                else:
                    name = station.station_name + "_{:.3f}".format(height)
                new_obstreestation = ObsTreeStation(new_station, name, "{}".format(int(count_dict[height])))
                count_dict[height] += 1
                obstreeloop.appendRow([new_obstreestation,
                                       QtGui.QStandardItem('a'),
                                       QtGui.QStandardItem('a')])
                height_idx = idx
                height = h

        obstreeloop.removeRow(0)
        self.index_current_station = obstreeloop.child(0).index()
        self.update_drift_tables_and_plots()
        self.deltas_update_required()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def divide_survey(self, loop_thresh):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a time interval, then scans the current
        loop and divides station occupations separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        # Store the original current loop index so it can be restored.
        original_loop_index = self.index_current_loop

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        indexes = []
        pbar = ProgressBar(total=obstreeloop.rowCount() - 1, textmess='Divide loop')
        pbar.show()
        pbar.progressbar.setValue(1)
        QtWidgets.QApplication.processEvents()
        # Step through loop backward
        pbar_idx = list(range(obstreeloop.rowCount()))
        pbar_idx.reverse()
        for i in range(obstreeloop.rowCount() - 1, 1, -1):
            station2 = obstreeloop.child(i)
            station1 = obstreeloop.child(i - 1)
            pbar.progressbar.setValue(pbar_idx[i])
            QtWidgets.QApplication.processEvents()
            # Check time difference between successive stations
            tdiff = station2.tmean() - station1.tmean()
            if tdiff > loop_thresh:
                for ii in range(i, obstreeloop.rowCount()):
                    indexes.append(obstreeloop.child(ii).index())
                self.new_loop_from_indexes(indexes)
                indexes = []
        self.index_current_loop = original_loop_index
        self.update_all_drift_plots()
        self.deltas_update_required()
        pbar.close()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def duplicate_station(self):
        """
        Create a duplicate of a station in the tree view. Useful when the same station is observed at the end of one
        day and the start of the next day: when imported, it will appear as one station, but it should be two.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        if len(indexes) > 3:
            self.msg = show_message("Please select a single station when duplicating.", "GSadjust error")
            return
        index = indexes[0]
        model = indexes[0].model()
        obstreeloop = model.itemFromIndex(indexes[0].parent())
        obstreesurvey = obstreeloop.parent()
        obstreestation = self.obsTreeModel.itemFromIndex(index)
        new_station_count = float(obstreestation.station_count) + 0.1
        new_obstreestation = ObsTreeStation(obstreestation, obstreestation.station_name,
                                            "{:.1f}".format(new_station_count))

        obstreeloop.insertRow(index.row() + 1, [new_obstreestation,
                                                QtGui.QStandardItem('a'),
                                                QtGui.QStandardItem('a')])
        logging.info("Station duplicated: {}, Survey: {}, Loop: {} ".format(new_obstreestation.station_name,
                                                                            obstreesurvey.name,
                                                                            obstreeloop.name))
        self.set_window_title_asterisk()

    def move_survey(self, direction=UP):
        """
        Used to move survey up or down in the tree view
        :param direction: UP or DOWN (macros for 1 and -1)
        :return:
        """
        if direction not in DIRECTIONS:
            return

        model = self.obsTreeModel
        index = self.index_current_survey
        row_number = index.row()
        new_row = row_number + direction
        if not (0 <= new_row < model.rowCount()):
            return False
        survey = model.takeRow(row_number)
        model.insertRow(new_row, survey)
        self.index_current_survey = model.indexFromItem(survey[0])
        self.set_window_title_asterisk()
        return True

    def new_loop(self):
        """
        Creates a new loop in tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        self.new_loop_from_indexes(indexes)
        self.activate_survey_or_loop(self.index_current_loop)
        self.update_drift_tables_and_plots(update=True)
        self.update_data_tab()
        self.set_window_title_asterisk()

    def new_loop_from_indexes(self, indexes):
        """
        Moves stations at the specified indexes to a new loop.
        :param indexes: PyQt indexes of selected stations
        """
        if len(indexes) > 0:
            model = indexes[0].model()
            obstreeloop = model.itemFromIndex(indexes[0].parent())
            obstreesurvey = obstreeloop.parent()
            new_loop_name = str(obstreesurvey.rowCount())
            # new loop, increment from loop parent
            new_obstreeloop = ObsTreeLoop(new_loop_name)

            # iterate over indexes
            # For whatever reason we can't just appendRow the 'itemFromIndex' directly. Instead, have to make a new
            # ObsTreeItem and append that. Probably has to do with needing to call the __init__ method of the PyQt obj.
            logging.info('Loop {} added'.format(new_loop_name))

            for idx in indexes:
                if idx.column() == 0:
                    obstreestation = model.itemFromIndex(idx)
                    new_obstreestation = ObsTreeStation(obstreestation,
                                                        obstreestation.station_name,
                                                        obstreestation.station_count)
                    logging.info('Station added to new loop: {}'.format(
                        obstreestation.station_name))
                    new_obstreeloop.appendRow([new_obstreestation,
                                               QtGui.QStandardItem('a'),
                                               QtGui.QStandardItem('a')])
            copy_fields = ['meter', 'oper', 'source']
            for field in copy_fields:
                try:
                    setattr(new_obstreeloop, field, getattr(obstreeloop, field))
                except:
                    setattr(new_obstreeloop, field, '')

            for idx in reversed(indexes):
                if idx.column() == 0:
                    self.obsTreeModel.beginRemoveRows(idx.parent(), idx.row(), idx.row() + 1)
                    self.obsTreeModel.removeRow(idx.row(), idx.parent())
                    self.obsTreeModel.endRemoveRows()
            obstreesurvey.appendRow(new_obstreeloop)
            self.gui_data_treeview.expand(new_obstreeloop.index())
            self.obsTreeModel.layoutChanged.emit()
            self.index_current_loop = new_obstreeloop.index()
            self.index_current_station = obstreeloop.child(0, 0).index()
            self.set_window_title_asterisk()

    def treeview_context_menu(self, point):
        """
        Right-click context menu on tree view
        """
        self.gui_data_treeview_popup_menu = QtWidgets.QMenu("Menu", self)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteSurvey)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteLoop)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopProperties)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationRename)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationDelete)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationDuplicate)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDataNewLoop)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopAnimate)
        # enable as appropriate
        indexes = self.gui_data_treeview.selectedIndexes()
        if indexes:
            index = indexes[0]
            item = index.model().itemFromIndex(index)
            if type(item) is ObsTreeStation:
                self.menus.set_state(MENU_STATE.OBS_TREE_STATION)
            elif type(item) is ObsTreeLoop:
                self.menus.set_state(MENU_STATE.OBS_TREE_LOOP)
            elif type(item) is ObsTreeSurvey:
                self.menus.set_state(MENU_STATE.OBS_TREE_SURVEY)

            self.gui_data_treeview_popup_menu.exec_(self.gui_data_treeview.mapToGlobal(point))

    def adjust_network(self, how_many='all'):
        """
        Carries out network adjustment, updates output tables
        """
        if self.menus.mnAdjPyLSQ.isChecked():
            adj_type = 'PyLSQ'
        else:
            adj_type = 'Gravnet'

        QtWidgets.QApplication.setOverrideCursor(QtCore.Qt.WaitCursor)
        # Collect checked items into adjustment object
        if self.label_deltas_update_required_set is True:
            reply = QtWidgets.QMessageBox.question(self, 'Message',
                                                   'The relative-gravity differences table on the Network Adjustment ' +
                                                   'tab is out of date. Proceed anyway?',
                                                   QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.No:
                return

        obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        # obstreesurvey.delta_model.layoutChanged.emit()
        # obstreesurvey.datum_model.layoutChanged.emit()
        # obstreesurvey.results_model.layoutChanged.emit()

        if how_many == 'all':
            for obstreesurvey in self.obsTreeModel.checked_surveys():
                obstreesurvey.run_inversion(adj_type)
        elif how_many == 'current':
            obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            obstreesurvey.run_inversion(adj_type)

        self.statusBar().showMessage("Network adjustment complete")
        self.update_adjust_tables()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.adjust_update_not_required()
        self.update_menus()


    def update_SD_and_run_adjustment(self):
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        ao = copy.deepcopy(obstreesurvey.adjustment.adjustmentoptions)
        if ao.use_sigma_min:
            ao.use_sigma_postfactor = True
            ao.sigma_postfactor = ao.sigma_postfactor * float(obstreesurvey.adjustment.SDaposteriori[0])
        else:
            ao.use_sigma_prefactor = True
            ao.sigma_prefactor = ao.sigma_prefactor * float(obstreesurvey.adjustment.SDaposteriori[0])
        obstreesurvey.adjustment.adjustmentoptions = ao
        self.set_adj_sd(obstreesurvey, ao)
        obstreesurvey.run_inversion()
        self.update_adjust_tables()
        self.adjust_update_not_required()
        self.update_menus()

    def show_gravity_change_table(self):
        data = compute_gravity_change(self.obsTreeModel)
        if data:
            win = GravityChangeTable(self, data, table_type='simple')
            win.show()

    def show_cal_coeff(self):
        cal_coeffs = self.obsTreeModel.get_cal_coeffs()
        if cal_coeffs:
            win = ShowCalCoeffs(cal_coeffs, parent=self)
            win.show()

    def plot_network_graph_circular(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plt = PlotNetworkGraph(survey, coords, shape='circular', parent=self)
        plt.show()

    def plot_network_graph_map(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plt = PlotNetworkGraph(survey, coords, shape='map', parent=self)
        plt.show()

    def plot_datum_vs_adjusted(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        plt = PlotDatumCompare(survey, self)
        plt.show()

    def plot_datum_comparison_timeseries(self):
        plt = PlotDatumComparisonTimeSeries(self.obsTreeModel, self)
        plt.show()

    def plot_histogram(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        plt = PlotDgResidualHistogram(survey, self)
        plt.show()

    def plot_gravity_change(self, dates, table, parent):
        plt = PlotGravityChange(dates, table, parent)
        plt.show()

    def set_adj_sd(self, survey, ao):
        """
        Update delta table based on parameters in net. adj. options
        :param survey: For which to set delta-g sd
        :param ao: AdjustmentOptions object
        """
        for i in range(survey.delta_model.rowCount()):
            ind = survey.delta_model.createIndex(i, 7)  # Column 7: minimum standard deviation
            delta = survey.delta_model.data(ind, role=QtCore.Qt.UserRole)
            additive = 0
            factor = 1
            if ao.use_sigma_add:
                additive = ao.sigma_add
            if ao.use_sigma_prefactor:
                factor = ao.sigma_prefactor
            if ao.use_sigma_min:
                sigma = max(ao.sigma_min, delta.sd * factor + additive)
                if ao.use_sigma_postfactor:
                    sigma *= ao.sigma_postfactor
            else:
                sigma = delta.sd * factor + additive
            survey.delta_model.setData(ind, sigma, role=QtCore.Qt.EditRole)
        self.update_adjust_tables()

    def menu_import_abs_g_simple(self):
        """
        Slot for mnAdjImportAbsSimple
        Returns
        -------

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None,
                                                         'Open file (3 columns, space delimited, station-g-std. dev.)',
                                                         self.settings.value('abs_g_path'))
        if fname:
            self.settings.setValue('abs_g_path', os.path.dirname(fname))
            logging.info('Importing absolute gravity data from {}'.format(fname))
            try:
                datums = import_abs_g_simple(fname)
            except IndexError:
                self.msg = show_message(
                    'Error reading absolute gravity file. Is it three columns (station, g, std. dev.), ' +
                    'space delimited', 'File read error')
            for datum in datums:
                self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(datum, 0)
                logging.info('Datum imported: {}'.format(datum.__str__()))
            self.set_window_title_asterisk()

    def menu_import_abs_g_complete(self):
        """
        Slot for mnAdjImportAbsFull

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(None, 'Open A10_parse.py output file',
                                                         self.settings.value('abs_g_path'))

        if fname:
            self.settings.setValue('abs_g_path', os.path.dirname(fname))
            logging.info('Importing absolute gravity data from {}'.format(fname))
            datums = import_abs_g_complete(fname)
            for datum in datums:
                self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(datum, 0)
                logging.info('Datum imported: {}'.format(datum.__str__()))
            self.set_window_title_asterisk()
        else:
            return

    def dialog_import_abs_g_direct(self):
        """
        Opens a PyQt dialog to select a directory with .project.txt files.
        """
        if self.obsTreeModel.rowCount() == 0:
            self.msg = show_message('Please load a survey before loading absolute-gravity data.',
                                    'Import error')
            return
        if hasattr(self, 'abs_import_table_model'):
            selectabsg = SelectAbsg(self.settings.value('abs_g_path'), datum_table_model=self.abs_import_table_model)
        else:
            selectabsg = SelectAbsg(self.settings.value('abs_g_path'))
        if selectabsg.exec_():
            nds = selectabsg.new_datums
            self.abs_import_table_model = selectabsg.table_model
            self.settings.setValue('abs_g_path', selectabsg.path)
            if nds:
                for nd in nds:
                    new_delta = copy.deepcopy(nd)
                    self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(new_delta, 0)
                self.set_window_title_asterisk()
        else:
            self.abs_import_table_model = selectabsg.table_model
        self.update_menus()

    def write_metadata_text(self):
        """
        Exports processing summary for metadata file.
        """
        fn = export_metadata(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(self, "Data export", "Metadata written to {}".format(fn))

    def write_summary_text(self):
        """
        Write complete summary of data and adjustment, with the intent that the processing can be re-created later
        """
        fn = export_summary(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(self, "Data export", "Text summary written to {}".format(fn))

    def write_tabular_data(self):
        """
        Write data to file
        """
        fn = export_data(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(self, "Data export", "Tabular data written to {}".format(fn))

    def dialog_add_datum(self):
        """
        Opens PyQt dialog to select an existing station to assign a datum value
        """
        stations = []
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
            for d in obstreesurvey.delta_list():
                stations.append(d.sta1)
                stations.append(d.sta2)
        station_list = list(set(stations))
        station_list.sort()
        station = AddDatumFromList.add_datum(station_list)
        if station:
            d = Datum(str(station))
            self.obsTreeModel.itemFromIndex(self.index_current_survey).datum_model.insertRows(d, 0)
            logging.info('Datum station added: {}'.format(station))
            self.set_window_title_asterisk()

    def dialog_adjustment_properties(self):
        """
        Opens PyQt dialog to set adjustment options
        """
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        adjust_options = AdjustOptions(survey.__str__(), survey.adjustment.adjustmentoptions, parent=self)
        if adjust_options.exec_():
            if adjust_options.surveys_to_update == 'single':
                # Not sure why the deepcopy is necessary. Without it, all of the survey.adjustmentoptions
                # reference the same object.
                ao = copy.deepcopy(adjust_options.ao)
                survey.adjustment.adjustmentoptions = ao
                self.set_adj_sd(survey, adjust_options.ao)
            elif adjust_options.surveys_to_update == 'all':
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    ao = copy.deepcopy(adjust_options.ao)
                    survey = self.obsTreeModel.invisibleRootItem().child(i)
                    survey.adjustment.adjustmentoptions = ao
                    self.set_adj_sd(survey, adjust_options.ao)
            self.set_window_title_asterisk()

    def dialog_tide_correction(self):
        """
        Opens PyQt dialog to specify correction type
        """
        tide_correction_dialog = TideCorrectionDialog()
        tide_correction_dialog.msg.exec_()
        correction_type = tide_correction_dialog.correction_type
        if correction_type == 'Cancel':
            return
        elif correction_type == 'Meter-supplied':
            tide_correction_meter(self)
        elif correction_type == 'Agnew':
            lat, lon, elev = [], [], []
            # Get mean coordinates as default position
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                for ii in range(survey.rowCount()):
                    loop = survey.child(ii)
                    for iii in range(loop.rowCount()):
                        station = loop.child(iii)
                        lat += station.lat
                        lon += station.long
                        elev += station.elev
            try:
                lat.remove(0.0)
            except ValueError:
                pass
            try:
                lon.remove(0.0)
            except ValueError:
                pass
            try:
                elev.remove(0.0)
            except ValueError:
                pass

            lat = np.mean(list(lat))
            lon = np.mean(list(lon))
            elev = np.mean(list(elev))

            tc = TideCoordinatesDialog(lat, lon, elev)
            if tc.exec_():
                tide_correction_agnew(self, float(tc.lat.text()),
                                      float(tc.lon.text()),
                                      float(tc.elev.text()))
            self.deltas_update_required()
            self.adjust_update_required()
        self.update_data_tab()

    def dialog_station_coordinates(self):
        """
        Shows station coordinates dialog.
        :return:
        """
        if not self.obsTreeModel.station_coords:
            init_station_coords_dict(self.obsTreeModel)
        coordinates_dialog = CoordinatesTable(self.obsTreeModel.station_coords)
        accept = coordinates_dialog.exec_()
        if accept == 1:
            self.obsTreeModel.station_coords = coordinates_dialog.coords()

    def load_station_coordinates(self):
        """
        Load station coordinates from file
        :return:
        """
        # TODO: load station coordinates dialog
        return

    def closeEvent(self, event):
        self.settings.sync()
        if self.windowTitle()[-1] == '*':
            quit_msg = "The workspace isn't saved. Are you sure you want to exit the program?"
            reply = QtWidgets.QMessageBox.question(self, 'Message',
                                                   quit_msg, QtWidgets.QMessageBox.Yes, QtWidgets.QMessageBox.No)

            if reply == QtWidgets.QMessageBox.Yes:
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()

    @staticmethod
    def show_help():
        """
        Shows compiled help file created using Dr. Explain
        """
        webbrowser.open('file://' + os.path.realpath('./docs/index.htm'))

    def dialog_about(self):
        if hasattr(self, 'commit'):
            AboutDialog(self.commit)
        else:
            AboutDialog('')

    def check_for_updates(self, show_uptodate_msg, parent=None):
        """
        Check if the usgs_root repo is at the same commit as this installation
        Parameters
        ----------
        e : qt event
        parent: Splash screen. Using this as the QMessageBox parent shows the MB centered over the splash screen.
        show_uptodate_msg : bool
           Whether to display a msg if no updates found
        Returns
        -------
        Booblean, whether or not to start GSadjust (True  yes)
        """
        try:
            gitpath = os.path.dirname(self.path_install) + "\\gsadjust-env\\Lib\\mingw64\\bin"
            os.environ["PATH"] += os.pathsep + gitpath
            from git import Repo
            logging.info('Checking for updates')
            repo = Repo(self.path_install)
            if not repo.active_branch.name == 'master':
                return True
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            for f in fetch:
                logging.info('Git fetched: {}'.format(f))
            self.commit = str(repo.head.commit)[:5]
            if repo.head.commit != master.commit:
                msg = "An update is available for GSadjust.\nWould you like to install now?"
                confirm = QtWidgets.QMessageBox.question(parent, "Update Available", msg,
                                                         QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No)
                if confirm == QtWidgets.QMessageBox.Yes:
                    return self.update_from_github()
            elif show_uptodate_msg:
                logging.info('Git checked, GSadjust is up to date.')
                msg = "GSadjust is up to date."
                QtWidgets.QMessageBox.information(self, "No Update Needed", msg)
                return True
            return True

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            if show_uptodate_msg:
                msg = 'Problem Encountered Updating from GitHub\n\nError Message:\n'
                msg += str(e)
                QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, start GSadjust anyway

    def update_from_github(self):
        """
        Merge the latest version of the Wizard into the local repo
        Returns
        -------
        None
        """

        try:
            from git import Repo
            # install_dir = utils.get_install_dname('pymdwizard')
            repo = Repo(self.path_install, )
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            repo.git.reset('--hard')
            repo.git.merge(master.name)
            logging.info('Git update successful')
            msg = 'Updated successfully downloaded from GitHub. Please\n' \
                  'restart GSadjust.'
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return False  # Don't launch GSadjust, need to restart to install updates

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            msg = 'Problem Encountered Updating from GitHub\n\n' \
                  'Please upgrade to the latest release by reinstalling the ' \
                  'application from GitHub ' \
                  '\n(https://github.com/jkennedy-usgs/sgp-gsadjust/releases)\n\n' \
                  'Error Message:\n'
            msg += str(e)
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, launch anyway

    def init_settings(self):
        """
        If it's the first time a user has opened ingestor, populate the directories/files

        :return: None
        """
        if self.settings.value('current_dir') is None:
            self.settings.setValue('current_dir', os.path.join(os.getcwd(), 'test_data'))
        if self.settings.value('abs_g_path') is None:
            self.settings.setValue('abs_g_path', os.getcwd())
        if self.settings.value('tide_path') is None:
            self.settings.setValue('tide_path', os.getcwd())
        if self.settings.value('delta_table_column_widths') is None:
            self.settings.setValue('delta_table_column_widths', None)
        if self.settings.value('datum_table_column_widths') is None:
            self.settings.setValue('datum_table_column_widths', None)
        if self.settings.value('results_table_column_widths') is None:
            self.settings.setValue('results_table_column_widths', None)
        if self.settings.value('data_table_column_widths') is None:
            self.settings.setValue('data_table_column_widths', None)


class BoldDelegate(QtWidgets.QStyledItemDelegate):
    """
    Makes selected item in tree view bold.
    See     http://www.qtcentre.org/threads/61716-Set-the-color-of-a-row-in-a-qtreeview
    """

    def paint(self, painter, option, index):
        m = index.model().itemFromIndex(index)
        # decide here if item should be bold and set font weight to bold if needed
        if not hasattr(m, 'fontweight'):
            option.font.setWeight(QtGui.QFont.Normal)
            m.cellcolor = QtCore.Qt.white
        else:
            option.font.setWeight(m.fontweight)
        painter.fillRect(option.rect, m.cellcolor)
        QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)


def handle_exception(exc_type, exc_value, exc_traceback):
    """ 
    Sends exceptions to log file
    """
    # KeyboardInterrupt is a special case, don't raise the error dialog when it occurs.
    if issubclass(exc_type, KeyboardInterrupt):
        if QtWidgets.qApp:
            QtWidgets.qApp.quit()
        return

    filename, line, dummy, dummy = traceback.extract_tb(exc_traceback).pop()
    filename = os.path.basename(filename)
    error = "{}: {}".format(exc_type.__name__, exc_value)
    logging.error(error + " at line {:d} of file {}".format(line, filename))


DEBUG = False


def main():
    app = QtWidgets.QApplication(sys.argv)
    # GSadjust starts in different directories on Mac and Windows
    # FIXME: Shouldn't need to change path here, you can
    # find the location of the current folder (see __file__ elsewhere) and
    # use relative paths from there for your project.
    if sys.platform == 'darwin':
        os.chdir('../')
    else:
        os.chdir('../sgp-gsadjust')

    # start log file
    fn = 'GSadjustLog_' + time.strftime("%Y%m%d-%H%M") + '.txt'
    # Should probably change this to try a different location for the log file.
    try:
        logging.basicConfig(filename=fn, format='%(levelname)s:%(message)s', level=logging.INFO)
    except PermissionError:
        self.msg = show_message('Please install GSadjust somewhere where admin rights are not required.',
                                'GSadjust error')

    splash_pix = QtGui.QPixmap(':/icons/Splash.png')
    splash = QtWidgets.QSplashScreen(splash_pix, QtCore.Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    ex = MainProg(splash=splash)
    app.processEvents()
    splash.finish(ex)
    app.setWindowIcon(QtGui.QIcon(':/icons/app.ico'))
    if not DEBUG:
        if ex.check_for_updates(False, parent=splash):
            # sys.excepthook = handle_exception
            ex.showMaximized()
            app.processEvents()
            app.exec_()
        else:
            ex.close()
    else:
        ex.showMaximized()
        app.processEvents()
        app.exec_()


if __name__ == '__main__':
    main()
