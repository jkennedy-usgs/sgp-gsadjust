#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
GSadjust, for the interactive network adjustment of relative-gravity networks
=============================================================================
Jeff Kennedy, USGS
jkennedy@usgs.gov

GSadjust is a Python 3.6/PyQt5 program that provides a graphical user interface
for post-processing combined relative- and absolute- gravity surveys.

GSadjust was originally based on PyGrav:
Hector, B. and Hinderer, J.: pyGrav, a Python-based program for handling and
processing relative gravity data, Computers & Geosciences
doi:10.1016/j.cageo.2016.03.010, 2016.

GSadjust is distributed with the network adjustment software Gravnet
(Windows executable) (Hwang, C., C. Wang and L. Lee. 2002. Adjustment of
relative gravity measurements using weighted and datum-free constraints.
Computers & Geosciences 28 1005-1015)

This software is preliminary, provisional, and is subject to revision. It is
being provided to meet the need for timely best science. The software has not
received final approval by the U.S. Geological Survey (USGS). No warranty,
expressed or implied, is made by the USGS or the U.S. Government as to the
functionality of the software and related material nor shall the fact of release
constitute any such warranty. The software is provided on the condition that
neither the USGS nor the U.S. Government shall be held liable for any damages
resulting from the authorized or unauthorized use of the software.

GSadjust file organization is:

GSadjust.py:
    major PyQt elements (tabs, menus)
tab_data.py
    PyQt elements on the data tab
tab_drift.py
    PyQt elements on the drift tab
tab_network.py
    PyQt elements on the network adjustment tab
menus.py
    Creates PyQt menus
gui_objects.py:
    minor PyQt elements (popup windows/dialogs)
data_objects.py:
    Non Py-Qt data objects (Deltas, Datums, etc.)
    Network adjustment code
pyqt_models.py:
    PyQt-specific data models: ObsTreeSurvey, ObsTreeLoop, etc.
tide_correction.py:
    Earth tide and ocean loading code
synthetic_tides.py:
    Tide model coefficients
a10.py:
    Parses *.project.txt files generated by 'g' software
    (A-10 and FG-5 absolute-gravity meters)

PyQt models follow the PyQt CamelCase naming convention. The other
methods/functions in GSadjust use PEP-8 lowercase_underscore convention.

The general data structure of the program is stored as PyQt objects inherited
from QStandardItem:

+------------+
| Campaign   |
++-----------+
 |  +---------------------------+
 +--+ Surveys (ObsTreeSurvey)   |
    ++--------------------------+
     |  +-------------+
     +--+ Adjustment  |
     |  +-------------+
     |  +-------------+
     +--+ datum_model |
     |  +-------------+
     |  +-------------+
     +--+ delta_model |
     |  +-------------+
     |  +---------------+
     +--+ results_model |
     |  +---------------+
     |  +----------------------+
     |--+ Loops (ObsTreeLoop)  |
        ++---------------------+
         |  +--------------+
         +--+ delta_model  |
            +--------------+
         |  +-------------+
         +--+ tare_model  |
            +-------------+
         |  +----------------------------+
         +--+ Stations (ObsTreeStation)  |
            ++---------------------------+
             |  +--------------------+
             +--+ g, lat, long, etc. |
                +--------------------+

The Adjustment object in each ObsTreeSurvey holds the network adjustment input,
output, and options. There is one Adjustment per Survey.

The datum_model, delta_model, results_model, and tare_model are PyQt models.
The gui is update with the respective model when a new Survey or Loop is
selected (by double-clicking in the tree view). There is one of each table per
Survey.

"""

import copy
import logging
import os

# Standard library modules
import sys
import time
import traceback
import webbrowser

import matplotlib

# Modules that must be installed
import numpy as np
from matplotlib.dates import num2date
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtCore import QSettings, Qt

from . import resources
from .data import ChannelList, Datum, Delta3Point, DeltaList, Tare, create_delta_by_type
from .data.analysis import compute_gravity_change
from .data.correction import time_correction
from .gui.dialogs import (
    AboutDialog,
    AddDatumFromList,
    AddTareDialog,
    AdjustOptions,
    CoordinatesTable,
    DialogApplyTimeCorrection,
    DialogLoopProperties,
    DialogMeterType,
    DialogOverwrite,
    GravityChangeTable,
    LoopTimeThresholdDialog,
    SelectAbsg,
    ShowCalCoeffs,
    TideCoordinatesDialog,
    TideCorrectionDialog,
    VerticalGradientDialog,
)
from .gui.menus import MENU_STATE, Menus
from .gui.messages import show_message
from .gui.tabs import TabAdjust, TabData, TabDrift
from .gui.widgets import ProgressBar

# GSadjust modules
from .io import (
    InvalidMeterException,
    export_data,
    export_metadata,
    export_summary,
    file_reader,
    import_abs_g_complete,
    import_abs_g_simple,
)
from .models import BurrisTableModel, ScintrexTableModel, TareTableModel
from .obstree import ObsTreeLoop, ObsTreeModel, ObsTreeStation, ObsTreeSurvey
from .plots import (
    PlotDatumCompare,
    PlotDatumComparisonTimeSeries,
    PlotDgResidualHistogram,
    PlotGravityChange,
    PlotLoopAnimation,
    PlotNetworkGraph,
)
from .tides import tide_correction_agnew, tide_correction_meter
from .utils import (
    assemble_all_deltas,
    init_cal_coeff_dict,
    init_station_coords_dict,
    return_delta_given_key,
)

matplotlib.use('qt5agg')


DOWN = 1
UP = -1
DIRECTIONS = (UP, DOWN)


class MainProg(QtWidgets.QMainWindow):
    """
    GSadjust main routine
    """

    path_output = None
    drift_lookup = {'none': 0, 'netadj': 1, 'roman': 2, 'continuous': 3}
    obsTreeModel = ObsTreeModel()
    previous_loop = None
    previous_survey = None
    vertical_gradient_interval = 64.2
    workspace_loaded = False
    DPI = 60  # resolution for data plots
    all_survey_data = None

    # PyQt indexes
    index_current_survey = None
    index_current_loop = None
    index_current_station = None
    index_current_loop_survey = None
    index_current_station_loop = None
    index_current_station_survey = None

    label_adjust_update_required_set = False
    label_deltas_update_required_set = False

    gui_obstreeview_popup_menu = None
    menus, selection_model = None, None
    tab_data, tab_drift, tab_adjust = None, None, None
    station_model = None
    workspace_savename = None

    def __init__(self, splash=None):
        super(MainProg, self).__init__()

        self.settings = QSettings('SGP', 'GSADJUST')
        self.init_settings()
        self.settings.sync()

        self.menus = Menus(self)
        # self.setGeometry(50, 50, 350, 300)
        self.setWindowTitle('GSadjust')

        # tab_....s are populated with GUI elements in the tab_...() functions
        self.tab_data = TabData(self)
        self.tab_drift = TabDrift(self)
        self.tab_adjust = TabAdjust(self)
        self.tab_widget = QtWidgets.QTabWidget()

        self.tab_widget = QtWidgets.QTabWidget()
        self.tab_widget.addTab(self.tab_data, 'Data')
        self.tab_widget.addTab(self.tab_drift, 'Drift')
        self.tab_widget.addTab(self.tab_adjust, 'Network Adjustment')
        self.tab_widget.setStyleSheet(
            "QTabBar::tab { font-size: 12pt; height: 40px; width: 250px }"
        )
        self.tab_widget.currentChanged.connect(self.tab_changed)

        self.gui_treeview_widget = QtWidgets.QWidget()
        self.gui_treeview_box = QtWidgets.QVBoxLayout()
        self.gui_data_treeview = QtWidgets.QTreeView()

        self.qtaction_move_station_up = QtWidgets.QAction(
            QtGui.QIcon(':/icons/up.png'), 'Move survey up', self
        )
        self.qtaction_move_station_up.triggered.connect(
            slot=lambda: self.move_survey(UP)
        )
        self.qtaction_move_station_down = QtWidgets.QAction(
            QtGui.QIcon(':/icons/down.png'), 'Move survey down', self
        )
        self.qtaction_move_station_down.triggered.connect(
            slot=lambda: self.move_survey(DOWN)
        )
        self.gui_toolbar = QtWidgets.QToolBar()
        self.gui_toolbar.addAction(self.qtaction_move_station_up)
        self.gui_toolbar.addAction(self.qtaction_move_station_down)

        self.qtaction_collapse_all = QtWidgets.QAction(
            QtGui.QIcon(':/icons/ca.png'), 'Collapse all', self
        )
        self.qtaction_collapse_all.triggered.connect(
            slot=self.gui_data_treeview.collapseAll
        )
        self.qtaction_expand_all = QtWidgets.QAction(
            QtGui.QIcon(':/icons/ea.png'), 'Expand all', self
        )
        self.qtaction_expand_all.triggered.connect(
            slot=self.gui_data_treeview.expandAll
        )

        self.gui_toolbar.addAction(self.qtaction_collapse_all)
        self.gui_toolbar.addAction(self.qtaction_expand_all)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjustCurrent)
        self.gui_toolbar.addAction(self.menus.mnAdjAdjust)
        self.gui_toolbar.addAction(self.menus.mnAdjUpdateSD)

        self.gui_treeview_box.addWidget(self.gui_toolbar)
        self.gui_treeview_box.addWidget(self.gui_data_treeview)
        self.gui_treeview_widget.setLayout(self.gui_treeview_box)

        self.gui_main_window_splitter = QtWidgets.QSplitter(Qt.Horizontal)
        self.gui_main_window_splitter.addWidget(self.gui_treeview_widget)
        self.gui_main_window_splitter.addWidget(self.tab_widget)
        self.setCentralWidget(self.gui_main_window_splitter)

        # Setup statusbar icons
        self.update_deltas_text = QtWidgets.QLabel("Update delta table:", self)
        self.update_adjust_text = QtWidgets.QLabel("    Update adjustment:", self)
        self.update_not_needed_icon = QtGui.QPixmap(':/icons/ico3.png')
        self.update_adjust_icon = QtGui.QPixmap(':/icons/ico2.png')
        self.update_deltas_icon = QtGui.QPixmap(':/icons/ico1.png')
        self.label_adjust_update_required = QtWidgets.QLabel()
        self.label_deltas_update_required = QtWidgets.QLabel()

        self.statusBar().addPermanentWidget(self.update_deltas_text)
        self.statusBar().addPermanentWidget(self.label_deltas_update_required)
        self.statusBar().addPermanentWidget(self.update_adjust_text)
        self.statusBar().addPermanentWidget(self.label_adjust_update_required)

        # Enabling these will show status indicators on startup. Leaving them
        # out to avoid confusion; they will be
        # set appropriately later
        # self.adjust_update_required()
        # self.deltas_update_required()

        # Right-click tree view context menu
        self.menus.mnDeleteSurvey = self.menus.create_action(
            'Delete survey', slot=self.delete_survey
        )
        self.menus.mnDeleteLoop = self.menus.create_action(
            'Delete loop', slot=self.delete_loop
        )
        self.menus.mnLoopProperties = self.menus.create_action(
            'Loop properties...', slot=self.properties_loop
        )
        self.menus.mnRename = self.menus.create_action('Rename', slot=self.rename)
        self.menus.mnDeleteStation = self.menus.create_action(
            'Delete station(s)', slot=self.delete_station
        )
        self.menus.mnStationDuplicate = self.menus.create_action(
            'Duplicate station', slot=self.duplicate_station
        )
        self.menus.mnDataNewLoop = self.menus.create_action(
            'Move stations to new loop', slot=self.new_loop
        )
        self.menus.mnVerticalGradientWriteAction = self.menus.create_action(
            "Write vertical gradient file...", slot=self.vertical_gradient_write
        )
        self.menus.mnLoopAnimate = self.menus.create_action(
            'Animate loop', slot=self.animate_loop
        )

        # self.resize(600,800)
        self.update_menus()
        self.path_install = os.getcwd()
        self.menus.set_state(MENU_STATE.UNINIT)

    def init_gui(self):
        """
        Called after loading a data file.
        """
        # Left panel: tree with data hierarchy (surveys, loops, stations)
        self.obsTreeModel.setHorizontalHeaderLabels(['Name', 'Date', 'g (\u00b5Gal)'])

        # Enable menus
        self.menus.set_state(MENU_STATE.INIT)

        # Resize, expand tree view
        self.gui_data_treeview.setModel(self.obsTreeModel)
        self.obsTreeModel.dataChanged.connect(self.on_obs_checked_change)
        # self.obsTreeModel.signal_refresh_view.connect(self.refresh_tables)
        self.obsTreeModel.signal_name_changed.connect(self.deltas_update_required)
        self.obsTreeModel.signal_delta_update_required.connect(
            self.deltas_update_required
        )
        self.selection_model = self.gui_data_treeview.selectionModel()
        self.selection_model.selectionChanged.connect(self.on_obs_tree_change)
        # self.data_treeview.setDragDropMode(QtWidgets.QAbstractItemView.InternalMove)

        self.gui_data_treeview.setSelectionMode(
            QtWidgets.QAbstractItemView.ExtendedSelection
        )
        self.gui_data_treeview.setContextMenuPolicy(Qt.CustomContextMenu)
        self.gui_data_treeview.customContextMenuRequested.connect(
            self.treeview_context_menu
        )
        self.gui_data_treeview.setItemDelegate(BoldDelegate(self))
        self.gui_data_treeview.doubleClicked.connect(self.activate_survey_or_loop)
        self.gui_data_treeview.setObjectName('data')
        self.gui_data_treeview.setEditTriggers(QtWidgets.QTreeView.EditKeyPressed)
        self.gui_data_treeview.setExpandsOnDoubleClick(False)
        self.gui_data_treeview.expandAll()
        self.gui_data_treeview.resizeColumnToContents(0)
        self.gui_data_treeview.resizeColumnToContents(1)
        self.gui_data_treeview.resizeColumnToContents(2)

        # Highlight first tree-view item
        self.select_first_treeview_item()

        # Activate first tree view item
        self.activate_survey_or_loop(self.index_current_loop)
        self.activate_survey_or_loop(self.index_current_survey)
        self.label_adjust_update_required_set = False
        # Set data plot
        self.update_data_tab()
        # self.selmodel.select(station.index(), QtCore.QItemSelectionModel.SelectCurrent)
        self.gui_data_treeview.setFocus()

    def adjust_update_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required_set = True
        self.label_adjust_update_required.setPixmap(self.update_adjust_icon)
        self.label_adjust_update_required.setToolTip('Update network adjustment')
        self.set_window_title_asterisk()
        self.update_menus()

    def adjust_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_adjust_update_required_set = False
        self.label_adjust_update_required.setPixmap(self.update_not_needed_icon)
        self.label_adjust_update_required.setToolTip('Network adjustment is up to date')

    def deltas_update_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required_set = True
        self.label_deltas_update_required.setPixmap(self.update_deltas_icon)
        self.label_deltas_update_required.setToolTip('Update delta table')
        self.set_window_title_asterisk()
        self.update_menus()

    def deltas_update_not_required(self):
        """
        Updates status bar icon
        """
        self.label_deltas_update_required_set = False
        self.label_deltas_update_required.setPixmap(self.update_not_needed_icon)
        self.label_deltas_update_required.setToolTip('Delta table is up to date')

    def select_first_treeview_item(self):
        """
        Selects the first item in the treeview
        """
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
        obstreeloop = obstreesurvey.child(0)
        station = obstreeloop.child(0)

        self.index_current_survey = obstreesurvey.index()
        self.index_current_loop = obstreeloop.index()
        self.index_current_loop_survey = obstreesurvey.index()
        self.index_current_station_loop = obstreeloop.index()
        self.index_current_station_survey = obstreesurvey.index()
        self.index_current_station = station.index()

    def tab_changed(self, new_idx):
        """
        Updates tab plots/tables as needed. These typically aren't updated
        unless they're visible.
        :param new_idx: Index of newly-selected tab.
        """
        if self.obsTreeModel.rowCount() > 0:
            if new_idx == 0:
                if self.index_current_station is not None:
                    self.update_data_tab()
            if new_idx == 1:
                if self.index_current_loop is not None:
                    self.update_drift_tables_and_plots()

    def update_data_tab(self):
        """
        Get station to plot, update station table model if necessary.
        """
        # Center panel: table (station values)
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreeloop = obstreestation.parent()
        station = obstreestation
        if obstreeloop.meter_type in ['CG5', 'Scintrex', 'CG6', 'csv', 'CG6Tsoft']:
            self.station_model = ScintrexTableModel(station)
        elif obstreeloop.meter_type == 'Burris':
            self.station_model = BurrisTableModel(station)
        self.station_model.dataChanged.connect(self.update_data_tab)
        self.station_model.signal_update_coordinates.connect(
            self.populate_station_coords
        )
        self.station_model.signal_adjust_update_required.connect(
            self.adjust_update_required
        )
        self.station_model.signal_uncheck_station.connect(self.uncheck_station)
        self.station_model.signal_check_station.connect(self.check_station)
        self.tab_data.data_view.setModel(self.station_model)
        self.index_current_station_loop = obstreeloop.index()
        self.index_current_station_survey = obstreeloop.parent().index()
        self.obsTreeModel.dataChanged.emit(QtCore.QModelIndex(), QtCore.QModelIndex())
        self.tab_data.update_station_plot(station, obstreeloop.meter_type)

    def uncheck_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(0)

    def check_station(self):
        obstreestation = self.obsTreeModel.itemFromIndex(self.index_current_station)
        obstreestation.setCheckState(2)

    ###########################################################################
    # Load/Open/Save routines
    ###########################################################################
    def open_file_dialog(self, open_type):
        """
        Called from menus.py functions
        Parameters
        ----------
        open_type

        Returns
        -------

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            caption='Open file', directory=self.settings.value('current_dir')
        )

        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            _, ext = os.path.splitext(fname)
            if ext in ['.p', '.gsa']:
                self.msg = show_message(
                    'Please use "Open workspace... " to load a .p or .gsa file',
                    'File load error',
                )
                return
            self.open_raw_data(fname, open_type)

    def open_raw_data(self, fname, open_type):
        """
        - Display a file opening window
        - Populate obsTreeModel
        :param open_type:
            'choose' - Choose meter-style data format
            'loop' - if appending loop to survey, otherwise assume appending
            survey to campaign (can be both choose and loop, e.g. 'chooseloop')
            'CG-6', 'Burris', or 'CG-5' - reading a raw data file, no appending
        """
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        # open file
        append_loop = True if open_type == 'loop' else False

        # When "append survey' or 'append loop' is called: accommodate the rare instance of combining meter
        # types on a single survey
        if open_type in ['loop', 'survey']:
            meter_type_dialog = DialogMeterType()
            test = meter_type_dialog.exec_()
            if test < 5:  # 5 = cancel  (accept/reject not working?)
                meter_type = meter_type_dialog.meter_type
            else:
                return
        else:
            meter_type = open_type
            if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
                overwrite_tree_dialog = DialogOverwrite()
                if overwrite_tree_dialog.exec_():
                    self.workspace_clear(confirm=False)
                else:
                    return

        if fname:
            self.path_output = os.path.dirname(fname)
            logging.info('Loading data file: %s', fname)

            # populate a Campaign object
            e = None
            try:
                self.all_survey_data = self.read_raw_data_file(fname, meter_type)
                if append_loop:
                    obstreesurvey = self.obsTreeModel.itemFromIndex(
                        self.index_current_survey
                    )
                    # Loads all survey data into a single loop.
                    obstreesurvey.populate(
                        self.all_survey_data,
                        name=str(obstreesurvey.loop_count),
                        source=os.path.basename(fname),
                    )
                else:
                    obstreesurvey = ObsTreeSurvey(
                        str(num2date(self.all_survey_data.t[0]).date())
                    )
                    obstreesurvey.populate(
                        self.all_survey_data, source=os.path.basename(fname)
                    )
                    self.obsTreeModel.appendRow(
                        [
                            obstreesurvey,
                            QtGui.QStandardItem('a'),
                            QtGui.QStandardItem('a'),
                        ]
                    )
            except IOError as err:
                e = err
                self.msg = show_message('No file : {}'.format(fname), 'File error')
            except (IndexError, ValueError) as err:
                stream = QtCore.QFile(":/text/err_{}.txt".format(meter_type))
                stream.open(QtCore.QIODevice.ReadOnly)
                text = QtCore.QTextStream(stream).readAll()
                stream.close()
                if hasattr(err, 'i') and hasattr(err, 'line'):
                    help_message = text.format(err.i, err.line)
                    self.msg = show_message(
                        'Error reading file at line {:d}'.format(err.i),
                        'File error',
                        helptext=help_message,
                    )
                else:
                    help_message = text.format("NA", "NA")
                    self.msg = show_message(
                        'Error reading file', 'File error', helptext=help_message
                    )
                e = err
            if e:
                logging.exception(e, exc_info=True)
                return False

            if self.obsTreeModel.rowCount() > 0:
                self.init_gui()
                if open_type is not 'CG5':
                    self.populate_station_coords()
                self.workspace_loaded = True
                QtWidgets.QApplication.restoreOverrideCursor()
                self.set_window_title_asterisk()
                QtWidgets.QApplication.processEvents()
                self.update_menus()
            else:
                QtWidgets.QApplication.restoreOverrideCursor()
                self.msg = show_message('Unknown import error', 'File error')
        else:
            QtWidgets.QApplication.restoreOverrideCursor()
            return False

    @staticmethod
    def read_raw_data_file(filename, meter_type):
        """
        Read raw relative-gravity text file in the format exported from meter
        (Scintrex or Burris). Data are returned to the calling function.
        :param filename: Full path to import file
        :param meter_type: 'Burris', 'CG-5', 'CG-6'
        :return all_survey_data: ChannelList object with all survey data
        """
        try:
            with open(filename, 'r') as fh:
                logging.info(
                    "number of lines: {:d}".format(
                        len([1 for line in open(filename, 'r')])
                    )
                )
                return file_reader(meter_type, fh)

        # Returning e like this allows exceptions to be tested in pytest
        except (InvalidMeterException, IOError, ValueError, IndexError) as e:
            raise e

    def workspace_append(self):
        """
        Append previously-saved workspace to current workspace.
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            None, 'Open File', self.settings.value('current_dir')
        )
        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            if fname[-1] is 'p':
                self.msg = show_message(
                    'If trying to append a .p file, please save it as a .gsa file first.',
                    'Import error',
                )
                return
            obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(
                fname
            )
            # TODO: Do something with coords (append to table if not already there)
            for survey in obstreesurveys:
                self.obsTreeModel.appendRow(
                    [survey, QtGui.QStandardItem('0'), QtGui.QStandardItem('0')]
                )
            self.update_all_drift_plots()
            self.populate_station_coords()
            self.workspace_loaded = True
            self.populate_survey_deltatable_from_simpledeltas(
                delta_models, obstreesurveys
            )
            QtWidgets.QApplication.restoreOverrideCursor()
            self.set_window_title_asterisk()
            self.update_menus()

    def workspace_clear(self, confirm=True):
        """
        Clears all models and refreshes view.
        """
        if confirm:
            if self.windowTitle()[-1] == '*':
                quit_msg = "The workspace isn't saved. Are you sure you want to clear all data?"
                reply = QtWidgets.QMessageBox.question(
                    self,
                    'Message',
                    quit_msg,
                    QtWidgets.QMessageBox.Yes,
                    QtWidgets.QMessageBox.No,
                )
                if reply == QtWidgets.QMessageBox.No:
                    return

        logging.info("Workspace cleared")
        self.obsTreeModel = ObsTreeModel()
        self.gui_data_treeview.setModel(None)
        self.gui_data_treeview.update()
        self.tab_data.clear_axes()
        self.tab_data.data_view.setModel(None)
        self.tab_data.data_view.update()
        self.tab_drift.delta_view.setModel(None)
        self.tab_drift.delta_view.update()
        self.tab_drift.dg_samples_view.setModel(None)
        self.tab_drift.dg_samples_view.update()
        self.tab_drift.clear_axes()
        self.tab_drift.drift_plot_weighted.setCheckState(0)
        self.tab_drift.drift_cont_startendcombobox.setCurrentIndex(0)
        self.tab_drift.drift_polydegree_combobox.setCurrentIndex(0)
        self.tab_drift.driftmethod_combobox.setCurrentIndex(0)
        self.tab_drift.tension_slider.setValue(1250)
        self.tab_adjust.delta_view.setModel(None)
        self.tab_adjust.delta_view.update()
        self.tab_adjust.datum_view.setModel(None)
        self.tab_adjust.datum_view.update()
        self.tab_adjust.results_view.setModel(None)
        self.tab_adjust.results_view.update()
        self.tab_adjust.stats_view.setModel(None)
        self.tab_adjust.stats_view.update()
        self.setWindowTitle('GSadjust')
        self.update_menus()

    def workspace_save(self):
        """
        Saves data if a workspace has already been saved
        """
        if self.label_deltas_update_required_set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network '
                'Adjustment tab is not up to date.',
                'Workspace save error',
            )
            return
        fname = self.obsTreeModel.save_workspace(self.workspace_savename)
        if not fname:
            self.msg = show_message("Workspace save error", "Error")
            return

        self.msg = show_message(
            'Workspace saved', 'GSadjust', icon=QtWidgets.QMessageBox.Information
        )
        self.set_window_title(fname)
        return True

    def workspace_save_as(self):
        """
        Saves data object using json.dump()
        """
        if self.label_deltas_update_required_set is True:
            self.msg = show_message(
                'Workspace cannot be saved while the Relative-gravity differences table on the Network '
                'Adjustment tab is not up to date.',
                'Workspace save error',
            )
            return

        fname, _ = QtWidgets.QFileDialog.getSaveFileName(
            None, 'Save workspace as', self.settings.value('current_dir')
        )
        if fname:
            self.settings.setValue('current_dir', os.path.dirname(fname))
            try:
                save_name = self.obsTreeModel.save_workspace(fname)
            except Exception as e:
                self.msg = show_message("Workspace save error", "Error")
                logging.exception(e, exc_info=True)
                self.menus.mnFileSaveWorkspace.setEnabled(False)
                return

            if not save_name:
                self.msg = show_message("Workspace save error", "Error")
                return

            self.set_window_title(fname)
            self.msg = show_message(
                'Workspace saved', 'GSadjust', icon=QtWidgets.QMessageBox.Information
            )
            self.workspace_savename = fname
            self.update_menus()

    def workspace_open_getjson(self):
        """
        Gets filename to open and asks whether to  append or overwrite, if applicable.
        :return:
        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            None, 'Open File', self.settings.value('current_dir')
        )
        if not fname:
            return
        elif fname[-4:] != '.gsa':
            self.msg = show_message(
                'Saved workspaces should have a .gsa extension. '
                'Please use "Open raw...data" to load a data file',
                'File load error',
            )
            return

        self.settings.setValue('current_dir', os.path.dirname(fname))
        if self.obsTreeModel.invisibleRootItem().rowCount() > 0:
            overwrite_tree_dialog = DialogOverwrite()
            if overwrite_tree_dialog.exec_():
                self.workspace_clear()
                self.workspace_open_json(fname)
            else:
                return
        else:
            self.workspace_open_json(fname)

    def workspace_open_json(self, fname):
        """
        Loads data from JSON file. Restores PyQt tables to Survey object
        """
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        # Returns list of survey delta tables so they can be passed to populate_survey_deltatable_from_simpledeltas()
        # try:
        QtWidgets.QApplication.processEvents()
        obstreesurveys, delta_models, coords = self.obsTreeModel.load_workspace(fname)
        if obstreesurveys:
            self.workspace_savename = fname
            self.populate_obstreemodel(obstreesurveys, delta_models)
            self.adjust_update_required()
            self.set_window_title(fname)
        if coords:
            self.obsTreeModel.station_coords = coords
        self.update_menus()

    def populate_obstreemodel(self, obstreesurveys, delta_models):
        """
        Only called for loading workspace, not when loading raw data.
        Parameters
        ----------
        obstreesurveys
        delta_models

        Returns
        -------

        """
        pbar = QtWidgets.QProgressDialog(
            labelText='Loading workspace', minimum=0, maximum=4
        )
        pbar.setWindowTitle('GSadjust')
        pbar.setLabelText('Building Observation Tree')
        pbar.show()
        for survey in obstreesurveys:
            self.obsTreeModel.appendRow(
                [survey, QtGui.QStandardItem('0'), QtGui.QStandardItem('0')]
            )
        pbar.setLabelText('Building Observation Tree')
        QtWidgets.QApplication.processEvents()
        if not delta_models:
            QtWidgets.QApplication.restoreOverrideCursor()
            return
        else:
            i = 0
            firststation = None
            # This avoids an error when the first loop (or subsequent loops) are empty
            firstsurvey = self.obsTreeModel.itemFromIndex(self.obsTreeModel.index(0, 0))
            while firststation is None:
                firstloop = firstsurvey.child(i)
                firststation = firstloop.child(0)
                i += 1
            pbar.setValue(1)
            pbar.setLabelText('Updating drift plots')
            QtWidgets.QApplication.processEvents()
            self.index_current_survey = firstsurvey.index()
            self.index_current_loop = firstloop.index()
            self.index_current_station = firststation.index()
            self.index_current_loop_survey = firstsurvey.index()
            self.index_current_station_loop = firstloop.index()
            self.index_current_station_survey = firstsurvey.index()
            try:
                self.populate_station_coords()
            except Exception as e:
                # sometimes coordinates aren't valid
                pass

            self.workspace_loaded = True
            self.update_all_drift_plots()
            pbar.setValue(2)
            pbar.setLabelText('Populating delta tables')
            QtWidgets.QApplication.processEvents()
            # The deltas on the survey delta table (on the network adjustment tab)
            # aren't saved. When loading a workspace, the loop deltas first have
            # to be created by update_all_drift_plots(), then the survey delta
            # table can be updated.
            self.populate_survey_deltatable_from_simpledeltas(
                delta_models, obstreesurveys
            )
            # for survey in obstreesurveys:
            #     self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

            self.update_adjust_tables()
            pbar.setValue(3)
            pbar.setLabelText('Initializing GUI')
            QtWidgets.QApplication.processEvents()
            self.init_gui()
            self.deltas_update_not_required()
            QtWidgets.QApplication.restoreOverrideCursor()
            pbar.setValue(4)
            pbar.close()

    def populate_survey_deltatable_from_simpledeltas(self, delta_models, surveys):
        """
        When workspaces are saved/loaded as json (.gsa files), there are 2 sets
        of deltas: those based on the data (drift-tab deltas), and those that
        might have edits (network-adjustment-tab deltas). The former we don't
        bother saving, the latter we do save. Deltas from the net adj tab are in
        turn based on other deltas (Roman method), and/or from stations directly
        ('normal' deltas). This function recreates the scheme from saved json by
        matching up stations with deltas and deltas with deltas.
        Parameters
        ----------
        delta_models: Python lists of deltas read from JSON file, one entry per survey
        surveys: List of ObsTreeSurvey objects

        Returns
        -------

        """
        deltas = self.obsTreeModel.deltas()
        for idx, delta_model in enumerate(delta_models):  # One delta_model per survey
            for simpledelta in delta_model:
                if not hasattr(simpledelta, 'loop'):
                    simpledelta.loop = None
                i = 0
                try:
                    if simpledelta.type == 'normal':
                        try:
                            if type(simpledelta) != Delta:
                                # Should be SimpleNamespace
                                # Lookup station based on hash
                                station1 = surveys[idx].return_obstreestation(
                                    simpledelta.sta1
                                )
                                station2 = surveys[idx].return_obstreestation(
                                    simpledelta.sta2
                                )
                                if station1 is not None and station2 is not None:
                                    d = create_delta_by_type(
                                        simpledelta.type,
                                        station1,
                                        station2,
                                        adj_sd=simpledelta.adj_sd,
                                        driftcorr=simpledelta.driftcorr,
                                        ls_drift=simpledelta.ls_drift,
                                        checked=simpledelta.checked,
                                        loop=simpledelta.loop,
                                    )

                            else:
                                # For dealing with old-style .p workspaces
                                d = simpledelta
                        except NameError:
                            logging.error('Delta re-creation error')
                    elif simpledelta.type == 'list':
                        if not hasattr(simpledelta, 'key'):
                            list_of_deltas = []
                            for delta in simpledelta.sta2:
                                station1 = surveys[idx].return_obstreestation(delta[0])
                                station2 = (
                                    surveys[idx].return_obstreestation(delta[1]),
                                    surveys[idx].return_obstreestation(delta[2]),
                                )
                                tpd = Delta3Point(
                                    station1,
                                    station2,
                                    adj_sd=simpledelta.adj_sd,
                                    driftcorr=simpledelta.driftcorr,
                                    ls_drift=simpledelta.ls_drift,
                                    checked=simpledelta.checked,
                                    loop=simpledelta.loop,
                                )
                                list_of_deltas.append(tpd)
                            d = DeltaList(None, list_of_deltas)
                            if simpledelta.adj_sd < 998:
                                d.adj_sd = simpledelta.adj_sd
                            # for sg, the 'list'-type delta returns the mean of all dg's, the user can't check/uncheck
                            # individual dg's. Therefore setting the check state when creating the three-point delta
                            # ("tpd", above) is meaningless. What we want to do is set the check state of the list
                            # delta.
                            d.checked = simpledelta.checked
                        # This section is necessary to load older .p versions. It's much slower than the above section.
                        else:
                            try:
                                d = return_delta_given_key(simpledelta.key, deltas)
                            except Exception:
                                return
                    elif simpledelta.type == 'assigned':
                        station1 = surveys[idx].return_obstreestation(simpledelta.sta1)
                        station2 = surveys[idx].return_obstreestation(simpledelta.sta2)
                        d = Delta(
                            station1,
                            station2,
                            adj_sd=simpledelta.adj_sd,
                            driftcorr=simpledelta.driftcorr,
                            ls_drift=simpledelta.ls_drift,
                            delta_type=simpledelta.type,
                            checked=simpledelta.checked,
                            loop=simpledelta.loop,
                        )
                        d.assigned_dg = simpledelta.assigned_dg
                    if d:
                        i += 1
                        surveys[idx].delta_model.insertRows(d, 0)
                    else:  # unable to create delta
                        self.msg = show_message(
                            'Import error',
                            'Error populating delta table. Please update delta '
                            'table on Adjust tab',
                        )
                except:
                    self.msg = show_message('Import error', 'Import error')

    def populate_station_coords(self):
        """
        Stores a single set of coordinates for each station with the
        obsTreeModel object. The coordinates of the last Station in the
        Survey > Loop > Station hierarchy are used.

        Used as a slot for the self.station_model.signal_update_coordinates
        signal (thus init_station_coords can't be called directly)
        """
        self.obsTreeModel.station_coords = init_station_coords_dict(self.obsTreeModel)

    ###########################################################################
    # General routines
    ###########################################################################
    def populate_deltamodel(self, populate_type):
        """
        Called from menu item
        :param populate_type: 'all', 'selectedLoop', or 'selectedSurvey'
        """
        table_updated = False

        if populate_type == 'all':
            self.update_all_drift_plots()
            for survey in self.obsTreeModel.checked_surveys():
                table_updated = survey.populate_delta_model(clear=True)
                self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

            # item = self.obsTreeModel.invisibleRootItem()
        elif populate_type == 'selectedsurvey':
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            self.update_survey_drift_plots(survey)
            table_updated = survey.populate_delta_model(clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        elif populate_type == 'selectedloop':
            selected_idx = self.gui_data_treeview.selectedIndexes()
            # There may be one, or multiple loops selected. If only one is
            # selected, we'll populate the delta table based on the
            # currentLoopIndex (which will be in bold but not necessarily highlighted).
            if len(selected_idx) >= 4:
                selected_items = []
                for i in selected_idx:
                    selected_items.append(self.obsTreeModel.itemFromIndex(i))
                # selected_items will contain 3 entries for every tree view
                # item (one for the name, plus 2 for
                # g and std. dev. First, decimate to just the name entries
                selected_items = selected_items[::3]
                loops = [item for item in selected_items if type(item) == ObsTreeLoop]
                first = True
                for loop in loops:
                    self.update_loop_drift_plots(loop)
                    survey = loop.parent()
                    if first:
                        table_updated = survey.populate_delta_model(loop, clear=True)
                        first = False
                    else:
                        table_updated = survey.populate_delta_model(loop, clear=False)
            else:
                loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
                survey = loop.parent()
                table_updated = survey.populate_delta_model(loop, clear=True)
            self.set_adj_sd(survey, survey.adjustment.adjustmentoptions)

        if table_updated:
            self.deltas_update_not_required()
            self.adjust_update_required()
            self.update_adjust_tables()
            self.tab_adjust.delta_proxy_model.sort(3)
        self.menus.set_state(MENU_STATE.DELTA_MODEL)

    def activate_survey_or_loop(self, index):
        """
        Highlights active survey or loop in tree view.
        :param index: PyQt index of newly-highlighted tree item, sent by
            doubleClicked event
        """
        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        item = self.obsTreeModel.itemFromIndex(index)
        try:
            # If a loop:
            if type(item) == ObsTreeLoop:
                if self.previous_loop is not None:
                    self.previous_loop.fontweight = QtGui.QFont.Normal
                    self.previous_loop.cellcolor = Qt.white
                self.previous_loop = item
                item.cellcolor = Qt.lightGray
                item.fontweight = QtGui.QFont.Bold
                self.index_current_loop = index
                if self.tab_widget.currentIndex() == 1:
                    self.update_drift_tables_and_plots()

            # If a survey
            elif type(item) == ObsTreeSurvey:
                if self.previous_survey is not None:
                    self.previous_survey.fontweight = QtGui.QFont.Normal
                self.previous_survey = item
                self.index_current_survey = index
                item.fontweight = QtGui.QFont.Bold
                self.update_adjust_tables()
        except Exception as e:
            logging.exception(e, exc_info=True)

        self.obsTreeModel.layoutChanged.emit()

        QtWidgets.QApplication.restoreOverrideCursor()

    def set_window_title(self, fname):
        self.setWindowTitle('GSadjust - ' + fname)

    def set_window_title_asterisk(self):
        title = self.windowTitle()
        last_char = title[-1]
        if last_char != '*':
            title += '*'
        self.setWindowTitle(title)

    def update_menus(self):
        """
        Set enabled/disabled states for menus.
        """
        if self.workspace_savename and self.windowTitle()[-1] == '*':
            self.menus.set_state(MENU_STATE.ACTIVE_WORKSPACE)
        else:
            self.menus.set_state(MENU_STATE.NO_ACTIVE_WORKSPACE)
        if self.obsTreeModel.rowCount() >= 1:
            self.menus.set_state(MENU_STATE.AT_LEAST_ONE_SURVEY)
            if self.obsTreeModel.invisibleRootItem().rowCount() > 1:
                self.menus.set_state(MENU_STATE.MORE_THAN_ONE_SURVEY)
                if not self.label_adjust_update_required_set:
                    self.menus.set_state(MENU_STATE.CALCULATE_CHANGE)
            try:
                current_survey = self.obsTreeModel.itemFromIndex(
                    self.index_current_survey
                )
                if current_survey.delta_model.rowCount() > 0:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_DELTAS)
                else:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_NO_DELTAS)
                if (
                    current_survey.results_model.rowCount() > 0
                    and not self.label_adjust_update_required_set
                ):
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_RESULTS)
                else:
                    self.menus.set_state(MENU_STATE.SURVEY_HAS_NO_RESULTS)
            except TypeError:
                # catches during PyTest
                return
            except AttributeError:
                # catches if no delta_model
                self.menus.set_state(MENU_STATE.UNINIT)
        else:
            self.menus.set_state(MENU_STATE.UNINIT)

        QtWidgets.QApplication.restoreOverrideCursor()

    def update_all_drift_plots(self):
        """
        Updates drift_tab plots and delta_models, even if not in view.
        """
        orig_loop_index = self.index_current_loop
        for survey in self.obsTreeModel.surveys():
            self.update_survey_drift_plots(survey)
        self.index_current_loop = orig_loop_index

    def update_survey_drift_plots(self, survey):
        for loop in survey.loops():
            self.update_loop_drift_plots(loop)

    def update_loop_drift_plots(self, loop):
        self.index_current_loop = loop.index()
        self.update_drift_tables_and_plots(update=False)

    def show_delta_update_message(self):
        self.msg = show_message(
            'The Delta-g value can only be edited if the drift-correction method for the '
            'respective loop is a method other than the Roman method.',
            'Delta error',
        )

    def update_adjust_tables(self):
        """
        Update delta-g and datum tables after selecting a new survey in the tree
        view, or after a network adjustment
        """

        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)

        survey.delta_model.layoutAboutToBeChanged.emit()
        survey.datum_model.layoutAboutToBeChanged.emit()
        survey.results_model.layoutAboutToBeChanged.emit()

        try:
            survey.delta_model.signal_adjust_update_required.connect(
                self.adjust_update_required
            )
            survey.delta_model.tried_to_update_list_delta.connect(
                self.show_delta_update_message
            )
            survey.datum_model.signal_adjust_update_required.connect(
                self.adjust_update_required
            )
            self.tab_adjust.delta_proxy_model.setSourceModel(survey.delta_model)
            self.tab_adjust.datum_proxy_model.setSourceModel(survey.datum_model)
            self.tab_adjust.results_proxy_model.setSourceModel(survey.results_model)
        except:
            pass
        self.tab_adjust.delta_proxy_model.invalidate()
        self.tab_adjust.datum_proxy_model.invalidate()
        self.tab_adjust.results_proxy_model.invalidate()
        self.tab_adjust.results_view.setModel(self.tab_adjust.results_proxy_model)
        self.tab_adjust.results_view.setSortingEnabled(True)
        self.tab_adjust.delta_view.setModel(self.tab_adjust.delta_proxy_model)
        self.tab_adjust.datum_view.setModel(self.tab_adjust.datum_proxy_model)
        stats_model = QtGui.QStandardItemModel()
        if survey.adjustment.adjustmentresults.n_unknowns > 0:  # Numpy adjustment

            for line in survey.adjustment.results_string():
                try:
                    line_elems = line.split(':')
                    if len(line_elems) == 2:  # normal line, stat: value
                        stats_model.appendRow(
                            [
                                QtGui.QStandardItem(line_elems[0]),
                                QtGui.QStandardItem(line_elems[1].strip()),
                            ]
                        )
                    else:  # Chi test accepted or rejected. No ":"
                        text = line_elems[0].strip()
                        qt_item = QtGui.QStandardItem(text)
                        if 'rejected' in text:
                            qt_item.setForeground(Qt.red)
                        stats_model.appendRow([qt_item, QtGui.QStandardItem('')])
                except:
                    pass
        elif survey.adjustment.adjustmentresults.text:  # Gravnet adjustment
            self.tab_adjust.stats_view.setColumnWidth(0, 600)
            stats_model.setColumnCount(1)
            stats_model.setHorizontalHeaderLabels([''])
            for line in survey.adjustment.adjustmentresults.text:
                stats_model.appendRow([QtGui.QStandardItem(line)])
        self.tab_adjust.stats_view.setModel(stats_model)
        stats_model.setColumnCount(2)
        stats_model.setHorizontalHeaderLabels(['', ''])
        self.tab_adjust.stats_view.setColumnWidth(0, 250)
        self.tab_adjust.stats_view.setColumnWidth(1, 150)
        self.tab_adjust.update_col_widths()

    def update_drift_tables_and_plots(self, update=True):
        """
        First updates the drift_method combobox, then calls set_drift_method
        to update plots.
        :param update: Plots are only updated if True. Saves time when
            loading a workspace.
        """

        drift_method = self.obsTreeModel.itemFromIndex(
            self.index_current_loop
        ).drift_method
        self.tab_drift.driftmethod_combobox.setCurrentIndex(
            self.drift_lookup[drift_method]
        )
        self.tab_drift.set_drift_method(update)

    def on_obs_checked_change(self, selected):
        """
        Called when a checkbox state is changed, but not when a new item
        selected. Should update drift plots if on drift tab, but otherwise
        do nothing.
        :param selected: Selected indexes
        """
        if selected.model() is not None:
            self.deltas_update_required()
            self.adjust_update_required()
            if self.tab_widget.currentIndex() == 0:
                self.update_drift_tables_and_plots(update=False)
            elif self.tab_widget.currentIndex() == 1:
                self.update_drift_tables_and_plots(update=True)
            elif self.tab_widget.currentIndex() == 2:
                self.update_drift_tables_and_plots(update=False)
                self.tab_adjust.delta_view.update()
                self.tab_adjust.delta_view.repaint()
        self.set_window_title_asterisk()
        self.update_menus()

    def on_obs_tree_change(self, selected):
        """
        Called when the selection model changes.
        :param selected: Selected indexes
        """
        indexes = selected.indexes()
        if indexes:
            item = self.obsTreeModel.itemFromIndex(indexes[0])
            if item:
                if type(item) is ObsTreeStation:
                    self.index_current_station = indexes[0]
                    if self.tab_widget.currentIndex() == 0:
                        self.update_data_tab()
                    if self.tab_widget.currentIndex() == 1:
                        self.update_drift_tables_and_plots()

    def adjusted_vs_observed_datum_analysis(self):
        return

    def correction_ocean_loading(self):
        self.msg = show_message('Not implemented', 'Error')

    def correction_atmospheric(self):
        self.msg = show_message('Not implemented', 'Error')

    def correct_recorded_time(self):
        """
        Correct all times from an offset: when GMT time entered in relative
        gravimeter is bad.
        """
        # ask for time difference to apply

        text, ok = QtWidgets.QInputDialog.getText(
            self, 'Input parameters', 'time offset to apply (min)?'
        )
        if ok:
            time_correction_dialog = DialogApplyTimeCorrection()
            time_correction_dialog.msg.exec_()
            correction_type = time_correction_dialog.time_correction_type
            if correction_type:
                time_correction(
                    self.obsTreeModel,
                    int(text),
                    self.index_current_survey,
                    self.index_current_loop,
                    self.gui_data_treeview.selectedIndexes(),
                )
                self.set_window_title_asterisk()

    def set_vertical_gradient_interval(self):
        """
        Dialog that queries user for the distance over which vertical gradient
        is measured.
        """
        interval = VerticalGradientDialog(self.vertical_gradient_interval)
        if interval.ok:
            self.vertical_gradient_interval = interval.text

    def vertical_gradient_write(self):
        """
        Writes a .grd file with two values: gradient and standard deviation.
        Only works when Roman drift method is used.
        """
        # Already verified that only a single loop is selected
        # Want to get the selected loop, not the self.index_current_loop (former is highlighted, latter is bold)
        current_loop_index = self.gui_data_treeview.selectedIndexes()[0]
        current_loop = self.obsTreeModel.itemFromIndex(current_loop_index)
        deltamodel = current_loop.delta_model
        n_stations = current_loop.n_unique_stations()

        dg, sd = None, None
        if n_stations == 2:
            stationname = (
                self.obsTreeModel.itemFromIndex(self.index_current_loop)
                .child(0)
                .station_name
            )
            defaultfile = os.path.join(
                self.settings.value('current_dir'), stationname + '.grd'
            )
            try:
                if current_loop.drift_method == 'roman':
                    filename, _ = QtWidgets.QFileDialog.getSaveFileName(
                        None, 'Vertical gradient file to write', defaultfile
                    )
                    if filename:
                        delta = deltamodel.data(
                            deltamodel.index(0, 0), role=QtCore.Qt.UserRole
                        )
                        dg = delta.dg
                        sd = delta.sd
                elif (
                    current_loop.drift_method == 'none'
                    or current_loop.drift_method == 'continuous'
                ):
                    filename, _ = QtWidgets.QFileDialog.getSaveFileName(
                        None, 'Vertical gradient file to write', defaultfile
                    )
                    if filename:
                        dg_list, sd_list = [], []
                        for i in range(deltamodel.rowCount()):
                            idx = deltamodel.index(i, 0)
                            delta = deltamodel.data(idx, QtCore.Qt.UserRole)
                            dg_list.append(delta.dg)
                            sd_list.append(delta.sd)
                        dg = np.mean(dg_list)
                        sd = np.mean(sd_list)
                else:
                    self.msg = show_message(
                        'When writing a vertical gradient the drift correction method must be '
                        '"None", "Roman", or "Continuous"'
                    )
                if dg:
                    with open(filename, 'w') as fid:
                        fid.write(
                            '{:0.2f}'.format(-1 * dg / self.vertical_gradient_interval)
                        )
                        fid.write(
                            ' +/- {:0.2f}'.format(sd / self.vertical_gradient_interval)
                        )
            except:
                self.msg = show_message(
                    'Error writing gradient file (try visiting the Drift tab then re-running this '
                    'command).',
                    'Vertical gradient error',
                )
        else:
            self.msg = show_message(
                'Writing a vertical gradient file requires that the respective loop has only '
                'two stations. The gradient interval is set '
                'by the "Vertical gradient interval..." menu command (instrument height in the '
                'meter file is ignored).',
                "Vertical gradient error",
            )

    def add_tare(self):
        """
        Opens a dialog to add tare to loop tare_model.
        """
        new_tare_date, new_tare_value = 0, 0
        current_loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        obstreestation = current_loop.child(0)
        default_time = num2date(obstreestation.t[0])
        taredialog = AddTareDialog(default_time)
        if taredialog.exec_():
            new_tare_date = taredialog.dt_edit.dateTime()
            new_tare_value = taredialog.edit_box.text()
        try:
            tare = Tare(new_tare_date.date(), new_tare_date.time(), new_tare_value)
        except:
            return
        if not hasattr(current_loop, 'tare_model'):
            current_loop.tare_model = TareTableModel
        current_loop.tare_model.insertRows(tare)
        self.tab_drift.process_tares(current_loop)
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def clear_delta_model(self):
        """
        Remove all deltas from survey delta model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(
            self.index_current_survey
        ).delta_model.clearDeltas()
        self.obsTreeModel.itemFromIndex(
            self.index_current_survey
        ).results_model.clearResults()
        self.clear_adjustment_text()
        self.deltas_update_required()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_adjustment_text(self):
        self.tab_adjust.stats_view.setModel(None)
        self.tab_adjust.stats_view.update()
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        survey.adjustment.adjustmentresults.text = []
        survey.adjustment.adjustmentresults.n_unknowns = 0

    def clear_datum_model(self):
        """
        Remove all datums from datum model shown on network adjustment tab.
        :return:
        """
        self.obsTreeModel.itemFromIndex(
            self.index_current_survey
        ).datum_model.clearDatums()
        self.obsTreeModel.itemFromIndex(
            self.index_current_survey
        ).results_model.clearResults()
        self.clear_adjustment_text()
        self.update_adjust_tables()
        self.set_window_title_asterisk()

    def clear_results_model(self):
        """
        Remove all results from results model shown on network adjustment tab.
        """
        self.obsTreeModel.itemFromIndex(
            self.index_current_survey
        ).results_model.clearResults()
        self.update_adjust_tables()

    def animate_loop(self):
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        coords = self.obsTreeModel.station_coords
        if not coords:
            self.msg = show_message('No station coordinates', 'GSadjust error')
        else:
            lat, lon, dates = [], [], []
            try:
                for station in loop.checked_stations():
                    lat.append(coords[station.station_name][1])
                    lon.append(coords[station.station_name][0])
                    dates.append(station.tmean())
                plt = PlotLoopAnimation([lat, lon, dates])
                plt.show()
            except:
                self.msg = show_message('Unknown error', 'GSadjust error')

    def properties_loop(self):
        """
        Show popup dialog to specify loop properties.
        :return:
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        loops = []
        for idx in indexes:
            if idx.column() == 0:
                loops.append(self.obsTreeModel.itemFromIndex(idx))
        loop_options = DialogLoopProperties(loops, parent=self)
        if loop_options.exec_():
            # Sync new meter numbers with station objects
            # for loop in self.loops:

            for loop in loops:
                loop.comment = loop_options.comment_edit.toPlainText()
                for i in range(loop.rowCount()):
                    obstreestation = loop.child(i)
                    obstreestation.meter = [loop_options.meter_edit.text()] * len(
                        obstreestation.meter
                    )
                    obstreestation.oper = [loop_options.operator_edit.text()] * len(
                        obstreestation.oper
                    )
            self.set_window_title_asterisk()
        self.update_data_tab()

    def delete_survey(self):
        """
        Remove loop or survey from tree view
        """
        # A little clunky. Setting self.index_current_survey earlier caused unhandled crashes
        index = self.gui_data_treeview.selectedIndexes()

        if index[0] == self.index_current_station_survey:
            update_selected_station = True
        else:
            update_selected_station = False

        if index[0] == self.index_current_survey:
            update_selected_survey = True
            old_row = index[0].row()
        else:
            update_selected_survey = False

        if len(self.obsTreeModel.surveys()) == 1:
            self.workspace_clear(confirm=False)
            self.update_menus()
            return

        self.obsTreeModel.beginRemoveRows(
            index[0].parent(), index[0].row(), index[0].row() + 1
        )
        self.obsTreeModel.removeRows(index[0].row(), 1, index[0].parent())
        self.obsTreeModel.endRemoveRows()

        if update_selected_survey:
            if old_row == 0:
                self.index_current_survey = self.obsTreeModel.index(0, 0)
            else:
                self.index_current_survey = self.obsTreeModel.index(old_row - 1, 0)
            if update_selected_station:
                obstreesurvey = self.obsTreeModel.itemFromIndex(
                    self.index_current_survey
                )
                first_loop = obstreesurvey.child(0)
                first_station = first_loop.child(0)
                self.index_current_station = first_station.index()
                self.update_data_tab()
        self.activate_survey_or_loop(self.index_current_survey)
        self.set_window_title_asterisk()
        self.update_menus()

    def delete_loop(self):
        """
        Remove loop or survey from tree view
        """
        index = self.gui_data_treeview.selectedIndexes()
        obstreesurvey = self.obsTreeModel.itemFromIndex(index[0]).parent()

        if index[0] == self.index_current_station_loop:
            update_selected_station = True
        else:
            update_selected_station = False

        if index[0] == self.index_current_loop:
            update_selected_loop = True
            old_row = index[0].row()
        else:
            update_selected_loop = False

        self.obsTreeModel.beginRemoveRows(
            index[0].parent(), index[0].row(), index[0].row() + 1
        )
        self.obsTreeModel.removeRows(index[0].row(), 1, index[0].parent())
        self.obsTreeModel.endRemoveRows()

        if obstreesurvey.rowCount() == 0:
            self.index_current_loop = None
            self.tab_drift.reset()
        else:
            if update_selected_loop:
                if old_row == 0:
                    loop = obstreesurvey.child(0)
                    self.index_current_loop = loop.index()
                else:
                    loop = obstreesurvey.child(old_row - 1)
                    self.index_current_loop = loop.index()
                if update_selected_station:
                    first_station = loop.child(0)
                    self.index_current_station = first_station.index()
                    self.update_data_tab()
                self.activate_survey_or_loop(self.index_current_loop)
        self.set_window_title_asterisk()
        self.update_menus()

    def rename(self):
        """
        Rename station; same as F2.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        # if len(indexes) > 3 or len(indexes) == 0:
        #     return
        # Because each tree item has three columns, len(indexes) equals the number of items selected * 3. The next
        # line takes every 3rd index.
        index = indexes[0]
        trigger = self.gui_data_treeview.EditKeyPressed
        event = None
        self.gui_data_treeview.edit(index, trigger, event)
        self.set_window_title_asterisk()

    def delete_station(self):
        """
        Remove station from tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()

        # Because each tree item has three columns, len(indexes) equals the
        # number of items selected * 3. The next line takes every 3rd index.
        indexes = indexes[0::3]
        for index in reversed(indexes):
            self.obsTreeModel.removeRow(index.row(), index.parent())
            self.set_window_title_asterisk()
        if index.row() > 0:
            self.index_current_station = index.sibling(index.row() - 1, 0)
        else:
            self.index_current_station = index.sibling(0, 0)

        first_index = indexes[0]
        if first_index.row() > 0:
            row = first_index.row() - 1
        else:
            row = 0
        new_selection_index = self.obsTreeModel.index(row, 0, first_index.parent())
        self.selection_model.select(
            new_selection_index, QtCore.QItemSelectionModel.SelectCurrent
        )
        self.update_data_tab()
        self.update_menus()

    def delete_tare(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_drift.tare_view.selectedIndexes()
        loop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        for idx in reversed(index):
            loop.tare_model.removeRow(idx)
        self.tab_drift.tare_view.update()
        self.tab_drift.process_tares(
            self.obsTreeModel.itemFromIndex(self.index_current_loop)
        )
        self.update_drift_tables_and_plots()
        self.set_window_title_asterisk()

    def delete_datum(self):
        """
        Called when user right-clicks a datum and selects delete from the context menu
        """
        index = self.tab_adjust.datum_view.selectedIndexes()
        i = [self.tab_adjust.datum_proxy_model.mapToSource(idx) for idx in index]
        i.sort(key=lambda x: x.row(), reverse=True)
        for idx in i:
            survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            survey.datum_model.removeRow(idx)
        self.tab_adjust.datum_view.update()
        self.set_window_title_asterisk()

    def divide_by_time(self):
        # Prompt user to select time threshold
        loopdialog = LoopTimeThresholdDialog()
        if loopdialog.exec_():
            loop_thresh = loopdialog.dt_edit.dateTime()
            # Convert to days. Subtract one from the date because the default is 1 (i.e., if the time set in the
            # loop dialog is 8:00, loop thresh is a Qdatetime equal to (2000,1,1,8,0).
            loop_thresh = (
                int(loop_thresh.toString("H")) / 24 + int(loop_thresh.toString("d")) - 1
            )
        else:
            return
        self.divide_survey(loop_thresh)

    def divide_by_height(self):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a
        time interval, then scans the current loop and divides station
        occupations separated by the time interval (or greater) into a loop.
        Useful primarily when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)

        if obstreeloop.rowCount() > 1:
            self.msg = show_message(
                "Loop must have a single station to divide by height.", "GSadjust error"
            )
            return

        station = obstreeloop.child(0)
        height = station.height[0]
        height_idx = 0
        n_samples = len(station.height)
        count_dict = dict()
        heights = set(station.height)
        for h in heights:
            count_dict[h] = 0
        for idx, h in enumerate(station.height):
            if h != height or idx == len(station.height) - 1:
                new_station = ChannelList()
                for k, v in station.__dict__.items():
                    try:  # some fields have no len()
                        if len(v) == n_samples:
                            # temp_sta = new_station.extract_subset_idx(height_idx, idx)
                            setattr(new_station, k, v[height_idx:idx])
                        else:
                            setattr(new_station, k, v)
                    except Exception:
                        continue

                # new_station = 0
                # # obstreestation = self.obsTreeModel.itemFromIndex(index)
                # new_station_count = float(obstreestation.station_count) + 0.1
                if height == 0:
                    name = station.station_name
                else:
                    name = station.station_name + "_{:.3f}".format(height)
                new_obstreestation = ObsTreeStation(
                    new_station, name, "{}".format(int(count_dict[height]))
                )
                count_dict[height] += 1
                obstreeloop.appendRow(
                    [
                        new_obstreestation,
                        QtGui.QStandardItem('a'),
                        QtGui.QStandardItem('a'),
                    ]
                )
                height_idx = idx
                height = h

        obstreeloop.removeRow(0)
        self.index_current_station = obstreeloop.child(0).index()
        self.update_drift_tables_and_plots()
        self.deltas_update_required()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def divide_survey(self, loop_thresh):
        """
        Called from "Divide loop..." menu command. Shows a dialog to specify a
        time interval, then scans the current loop and divides station occupations
        separated by the time interval (or greater) into a loop. Useful primarily
        when several day's data is in a single file.
        """
        # Clear survey delta table, it causes problems otherwise
        self.clear_delta_model()

        # Store the original current loop index so it can be restored.
        original_loop_index = self.index_current_loop

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        obstreeloop = self.obsTreeModel.itemFromIndex(self.index_current_loop)
        indexes = []
        pbar = ProgressBar(total=obstreeloop.rowCount() - 1, textmess='Divide loop')
        pbar.show()
        pbar.progressbar.setValue(1)
        QtWidgets.QApplication.processEvents()
        # Step through loop backward
        pbar_idx = list(range(obstreeloop.rowCount()))
        pbar_idx.reverse()
        for i in range(obstreeloop.rowCount() - 1, 1, -1):
            station2 = obstreeloop.child(i)
            station1 = obstreeloop.child(i - 1)
            pbar.progressbar.setValue(pbar_idx[i])
            QtWidgets.QApplication.processEvents()
            # Check time difference between successive stations
            tdiff = station2.tmean() - station1.tmean()
            if tdiff > loop_thresh:
                for ii in range(i, obstreeloop.rowCount()):
                    indexes.append(obstreeloop.child(ii).index())
                self.new_loop_from_indexes(indexes)
                indexes = []
        self.index_current_loop = original_loop_index
        self.update_all_drift_plots()
        self.deltas_update_required()
        pbar.close()
        self.obsTreeModel.layoutChanged.emit()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.set_window_title_asterisk()

    def duplicate_station(self):
        """
        Create a duplicate of a station in the tree view. Useful when the same
        station is observed at the end of one day and the start of the next day:
        when imported, it will appear as one station, but it should be two.
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        if len(indexes) > 3:
            self.msg = show_message(
                "Please select a single station when duplicating.", "GSadjust error"
            )
            return
        index = indexes[0]
        model = indexes[0].model()
        obstreeloop = model.itemFromIndex(indexes[0].parent())
        obstreesurvey = obstreeloop.parent()
        obstreestation = self.obsTreeModel.itemFromIndex(index)
        new_station_count = float(obstreestation.station_count) + 0.1
        new_obstreestation = ObsTreeStation(
            obstreestation,
            obstreestation.station_name,
            "{:.1f}".format(new_station_count),
        )

        obstreeloop.insertRow(
            index.row() + 1,
            [new_obstreestation, QtGui.QStandardItem('a'), QtGui.QStandardItem('a')],
        )
        logging.info(
            "Station duplicated: {}, Survey: {}, Loop: {} ".format(
                new_obstreestation.station_name, obstreesurvey.name, obstreeloop.name
            )
        )
        self.set_window_title_asterisk()

    def move_survey(self, direction=UP):
        """
        Used to move survey up or down in the tree view
        :param direction: UP or DOWN (macros for 1 and -1)
        :return:
        """
        if direction not in DIRECTIONS:
            return

        model = self.obsTreeModel
        index = self.index_current_survey
        row_number = index.row()
        new_row = row_number + direction
        if not (0 <= new_row < model.rowCount()):
            return False
        survey = model.takeRow(row_number)
        model.insertRow(new_row, survey)
        self.index_current_survey = model.indexFromItem(survey[0])
        self.set_window_title_asterisk()
        return True

    def new_loop(self):
        """
        Creates a new loop in tree view
        """
        indexes = self.gui_data_treeview.selectedIndexes()
        self.new_loop_from_indexes(indexes)
        self.activate_survey_or_loop(self.index_current_loop)
        self.update_drift_tables_and_plots(update=True)
        self.update_data_tab()
        self.set_window_title_asterisk()

    def new_loop_from_indexes(self, indexes):
        """
        Moves stations at the specified indexes to a new loop.
        :param indexes: PyQt indexes of selected stations
        """
        if len(indexes) > 0:
            model = indexes[0].model()
            obstreeloop = model.itemFromIndex(indexes[0].parent())
            obstreesurvey = obstreeloop.parent()
            new_loop_name = str(obstreesurvey.rowCount())
            # new loop, increment from loop parent
            new_obstreeloop = ObsTreeLoop(new_loop_name)

            # iterate over indexes
            # For whatever reason we can't just appendRow the 'itemFromIndex'
            # directly. Instead, have to make a new ObsTreeItem and append that.
            # Probably has to do with needing to call the __init__ method of the PyQt obj.
            logging.info('Loop {} added'.format(new_loop_name))

            for idx in indexes:
                if idx.column() == 0:
                    obstreestation = model.itemFromIndex(idx)
                    new_obstreestation = ObsTreeStation(
                        obstreestation,
                        obstreestation.station_name,
                        obstreestation.station_count,
                    )
                    logging.info(
                        'Station added to new loop: {}'.format(
                            obstreestation.station_name
                        )
                    )
                    new_obstreeloop.appendRow(
                        [
                            new_obstreestation,
                            QtGui.QStandardItem('a'),
                            QtGui.QStandardItem('a'),
                        ]
                    )
            copy_fields = ['source']
            for field in copy_fields:
                try:
                    setattr(new_obstreeloop, field, getattr(obstreeloop, field))
                except:
                    setattr(new_obstreeloop, field, '')

            for idx in reversed(indexes):
                if idx.column() == 0:
                    self.obsTreeModel.beginRemoveRows(
                        idx.parent(), idx.row(), idx.row() + 1
                    )
                    self.obsTreeModel.removeRow(idx.row(), idx.parent())
                    self.obsTreeModel.endRemoveRows()
            obstreesurvey.appendRow(new_obstreeloop)
            self.gui_data_treeview.expand(new_obstreeloop.index())
            self.obsTreeModel.layoutChanged.emit()
            self.index_current_loop = new_obstreeloop.index()
            self.index_current_station = obstreeloop.child(0, 0).index()
            self.set_window_title_asterisk()

    def treeview_context_menu(self, point):
        """
        Right-click context menu on tree view
        """
        self.gui_data_treeview_popup_menu = QtWidgets.QMenu("Menu", self)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnRename)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteSurvey)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteLoop)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopProperties)
        self.gui_data_treeview_popup_menu.addAction(
            self.menus.mnVerticalGradientWriteAction
        )
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnLoopAnimate)
        self.gui_data_treeview_popup_menu.addSeparator()
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDeleteStation)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnStationDuplicate)
        self.gui_data_treeview_popup_menu.addAction(self.menus.mnDataNewLoop)
        # enable as appropriate
        indexes = self.gui_data_treeview.selectedIndexes()

        if len(indexes) == 3:  # One item is selected
            index = indexes[0]
            item = index.model().itemFromIndex(index)
            if type(item) is ObsTreeStation:
                self.menus.set_state(MENU_STATE.OBS_TREE_STATION)
            elif type(item) is ObsTreeLoop:
                self.menus.set_state(MENU_STATE.OBS_TREE_LOOP)
            elif type(item) is ObsTreeSurvey:
                self.menus.set_state(MENU_STATE.OBS_TREE_SURVEY)
        elif len(indexes) > 3:
            index_types = [
                type(index.model().itemFromIndex(index)) for index in indexes[0::3]
            ]
            if all([it == ObsTreeStation for it in index_types]):
                self.menus.set_state(MENU_STATE.MULTIPLE_STATION)
            else:
                self.menus.set_state(MENU_STATE.UNENABLE_ALL)
        else:
            self.menus.set_state(MENU_STATE.UNENABLE_ALL)
        self.gui_data_treeview_popup_menu.exec_(
            self.gui_data_treeview.mapToGlobal(point)
        )

    def adjust_network(self, how_many='all'):
        """
        Carries out network adjustment, updates output tables
        """
        if self.menus.mnAdjPyLSQ.isChecked():
            adj_type = 'PyLSQ'
        else:
            adj_type = 'Gravnet'

        QtWidgets.QApplication.setOverrideCursor(Qt.WaitCursor)
        # Collect checked items into adjustment object
        if self.label_deltas_update_required_set is True:
            reply = QtWidgets.QMessageBox.question(
                self,
                'Message',
                'The relative-gravity differences table on the Network Adjustment '
                + 'tab is out of date. Proceed anyway?',
                QtWidgets.QMessageBox.Yes,
                QtWidgets.QMessageBox.No,
            )

            if reply == QtWidgets.QMessageBox.No:
                return

        obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        # obstreesurvey.delta_model.layoutChanged.emit()
        # obstreesurvey.datum_model.layoutChanged.emit()
        # obstreesurvey.results_model.layoutChanged.emit()

        if how_many == 'all':
            for obstreesurvey in self.obsTreeModel.checked_surveys():
                obstreesurvey.run_inversion(adj_type)
        elif how_many == 'current':
            obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
            obstreesurvey.run_inversion(adj_type)

        self.statusBar().showMessage("Network adjustment complete")
        self.update_adjust_tables()
        QtWidgets.QApplication.restoreOverrideCursor()
        self.adjust_update_not_required()
        self.update_menus()

    def update_SD_and_run_adjustment(self):
        obstreesurvey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        ao = copy.deepcopy(obstreesurvey.adjustment.adjustmentoptions)
        if ao.use_sigma_min:
            ao.use_sigma_postfactor = True
            ao.sigma_postfactor = ao.sigma_postfactor * float(
                obstreesurvey.adjustment.SDaposteriori[0]
            )
        else:
            ao.use_sigma_prefactor = True
            ao.sigma_prefactor = ao.sigma_prefactor * float(
                obstreesurvey.adjustment.SDaposteriori[0]
            )
        obstreesurvey.adjustment.adjustmentoptions = ao
        self.set_adj_sd(obstreesurvey, ao)
        obstreesurvey.run_inversion()
        self.update_adjust_tables()
        self.adjust_update_not_required()
        self.update_menus()

    def show_gravity_change_table(self):
        data = compute_gravity_change(self.obsTreeModel)
        if data:
            win = GravityChangeTable(self, data, table_type='simple')
            win.show()

    def show_cal_coeff(self):
        cal_coeffs = self.obsTreeModel.get_cal_coeffs()
        if cal_coeffs:
            win = ShowCalCoeffs(cal_coeffs, parent=self)
            win.show()

    def plot_network_graph_circular(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plt = PlotNetworkGraph(survey, coords, shape='circular', parent=self)
        plt.show()

    def plot_network_graph_map(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        coords = self.obsTreeModel.station_coords
        plt = PlotNetworkGraph(survey, coords, shape='map', parent=self)
        plt.show()

    def plot_datum_vs_adjusted(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        plt = PlotDatumCompare(survey, self)
        plt.show()

    def plot_datum_comparison_timeseries(self):
        plt = PlotDatumComparisonTimeSeries(self.obsTreeModel, self)
        plt.show()

    def plot_histogram(self):
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        plt = PlotDgResidualHistogram(survey, self)
        plt.show()

    def plot_gravity_change(self, dates, table, parent):
        plt = PlotGravityChange(dates, table, parent)
        plt.show()

    def set_adj_sd(self, survey, ao):
        """
        Update delta table based on parameters in net. adj. options
        :param survey: For which to set delta-g sd
        :param ao: AdjustmentOptions object
        """
        for i in range(survey.delta_model.rowCount()):
            ind = survey.delta_model.createIndex(
                i, 7
            )  # Column 7: minimum standard deviation
            delta = survey.delta_model.data(ind, role=Qt.UserRole)
            additive = 0
            factor = 1
            if ao.use_sigma_add:
                additive = ao.sigma_add
            if ao.use_sigma_prefactor:
                factor = ao.sigma_prefactor
            if ao.use_sigma_min:
                sigma = max(ao.sigma_min, delta.sd * factor + additive)
                if ao.use_sigma_postfactor:
                    sigma *= ao.sigma_postfactor
            else:
                sigma = delta.sd * factor + additive
            survey.delta_model.setData(ind, sigma, role=Qt.EditRole)
        self.update_adjust_tables()

    def menu_import_abs_g_simple(self):
        """
        Slot for mnAdjImportAbsSimple
        Returns
        -------

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            None,
            'Open file (3 columns, space delimited, station-g-std. dev.)',
            self.settings.value('abs_g_path'),
        )
        if fname:
            self.settings.setValue('abs_g_path', os.path.dirname(fname))
            logging.info('Importing absolute gravity data from {}'.format(fname))
            try:
                datums = import_abs_g_simple(fname)
            except IndexError:
                self.msg = show_message(
                    'Error reading absolute gravity file. Is it three columns (station, g, std. dev.), '
                    + 'space delimited',
                    'File read error',
                )
            for datum in datums:
                self.obsTreeModel.itemFromIndex(
                    self.index_current_survey
                ).datum_model.insertRows(datum, 0)
                logging.info('Datum imported: {}'.format(datum.__str__()))
            self.set_window_title_asterisk()

    def menu_import_abs_g_complete(self):
        """
        Slot for mnAdjImportAbsFull

        """
        fname, _ = QtWidgets.QFileDialog.getOpenFileName(
            None, 'Open A10_parse.py output file', self.settings.value('abs_g_path')
        )

        if fname:
            self.settings.setValue('abs_g_path', os.path.dirname(fname))
            logging.info('Importing absolute gravity data from {}'.format(fname))
            datums = import_abs_g_complete(fname)
            for datum in datums:
                self.obsTreeModel.itemFromIndex(
                    self.index_current_survey
                ).datum_model.insertRows(datum, 0)
                logging.info('Datum imported: {}'.format(datum.__str__()))
            self.set_window_title_asterisk()
        else:
            return

    def dialog_import_abs_g_direct(self):
        """
        Opens a PyQt dialog to select a directory with .project.txt files.
        """
        if self.obsTreeModel.rowCount() == 0:
            self.msg = show_message(
                'Please load a survey before loading absolute-gravity data.',
                'Import error',
            )
            return
        if hasattr(self, 'abs_import_table_model'):
            selectabsg = SelectAbsg(
                self.settings.value('abs_g_path'),
                datum_table_model=self.abs_import_table_model,
            )
        else:
            selectabsg = SelectAbsg(self.settings.value('abs_g_path'))
        if selectabsg.exec_():
            nds = selectabsg.new_datums
            self.abs_import_table_model = selectabsg.table_model
            self.settings.setValue('abs_g_path', selectabsg.path)
            if nds:
                for nd in nds:
                    new_delta = copy.deepcopy(nd)
                    self.obsTreeModel.itemFromIndex(
                        self.index_current_survey
                    ).datum_model.insertRows(new_delta, 0)
                self.set_window_title_asterisk()
        else:
            self.abs_import_table_model = selectabsg.table_model
        self.update_menus()

    def write_metadata_text(self):
        """
        Exports processing summary for metadata file.
        """
        fn = export_metadata(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(
                self, "Data export", "Metadata written to {}".format(fn)
            )
        else:
            show_message('No network adjustment results', 'Write error')

    def write_summary_text(self):
        """
        Write complete summary of data and adjustment, with the intent that the
        processing can be re-created later
        """
        fn = export_summary(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(
                self, "Data export", "Text summary written to {}".format(fn)
            )

    def write_tabular_data(self):
        """
        Write data to file
        """
        fn = export_data(self.obsTreeModel, self.settings.value('current_dir'))
        if fn:
            QtWidgets.QMessageBox.information(
                self, "Data export", "Tabular data written to {}".format(fn)
            )

    def dialog_add_datum(self):
        """
        Opens PyQt dialog to select an existing station to assign a datum value
        """
        stations = []
        for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
            obstreesurvey = self.obsTreeModel.invisibleRootItem().child(i)
            for d in obstreesurvey.delta_list():
                stations.append(d.sta1)
                stations.append(d.sta2)
        station_list = list(set(stations))
        station_list.sort()
        station = AddDatumFromList.add_datum(station_list)
        if station:
            d = Datum(str(station))
            self.obsTreeModel.itemFromIndex(
                self.index_current_survey
            ).datum_model.insertRows(d, 0)
            logging.info('Datum station added: {}'.format(station))
            self.set_window_title_asterisk()

    def dialog_adjustment_properties(self):
        """
        Opens PyQt dialog to set adjustment options
        """
        survey = self.obsTreeModel.itemFromIndex(self.index_current_survey)
        adjust_options = AdjustOptions(
            survey.__str__(), survey.adjustment.adjustmentoptions, parent=self
        )
        if adjust_options.exec_():
            if adjust_options.surveys_to_update == 'single':
                # Not sure why the deepcopy is necessary. Without it, all of the survey.adjustmentoptions
                # reference the same object.
                ao = copy.deepcopy(adjust_options.ao)
                survey.adjustment.adjustmentoptions = ao
                self.set_adj_sd(survey, adjust_options.ao)
            elif adjust_options.surveys_to_update == 'all':
                for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                    ao = copy.deepcopy(adjust_options.ao)
                    survey = self.obsTreeModel.invisibleRootItem().child(i)
                    survey.adjustment.adjustmentoptions = ao
                    self.set_adj_sd(survey, adjust_options.ao)
            self.set_window_title_asterisk()

    def dialog_tide_correction(self):
        """
        Opens PyQt dialog to specify correction type
        """
        tide_correction_dialog = TideCorrectionDialog()
        tide_correction_dialog.msg.exec_()
        correction_type = tide_correction_dialog.correction_type
        if correction_type == 'Cancel':
            return
        elif correction_type == 'Meter-supplied':
            tide_correction_meter(self)
        elif correction_type == 'Agnew':
            lat, lon, elev = [], [], []
            # Get mean coordinates as default position
            for i in range(self.obsTreeModel.invisibleRootItem().rowCount()):
                survey = self.obsTreeModel.invisibleRootItem().child(i)
                for ii in range(survey.rowCount()):
                    loop = survey.child(ii)
                    for iii in range(loop.rowCount()):
                        station = loop.child(iii)
                        lat += station.lat
                        lon += station.long
                        elev += station.elev
            try:
                lat.remove(0.0)
            except ValueError:
                pass
            try:
                lon.remove(0.0)
            except ValueError:
                pass
            try:
                elev.remove(0.0)
            except ValueError:
                pass

            lat = np.mean(list(lat))
            lon = np.mean(list(lon))
            elev = np.mean(list(elev))

            tc = TideCoordinatesDialog(lat, lon, elev)
            if tc.exec_():
                tide_correction_agnew(
                    self,
                    float(tc.lat.text()),
                    float(tc.lon.text()),
                    float(tc.elev.text()),
                )
            self.deltas_update_required()
            self.adjust_update_required()
        self.update_data_tab()

    def dialog_station_coordinates(self):
        """
        Shows station coordinates dialog.
        :return:
        """
        if not self.obsTreeModel.station_coords:
            init_station_coords_dict(self.obsTreeModel)
        coordinates_dialog = CoordinatesTable(self.obsTreeModel.station_coords)
        accept = coordinates_dialog.exec_()
        if accept == 1:
            self.obsTreeModel.station_coords = coordinates_dialog.coords()

    def load_station_coordinates(self):
        """
        Load station coordinates from file
        :return:
        """
        # TODO: load station coordinates dialog
        return

    def closeEvent(self, event):
        self.settings.sync()
        if self.windowTitle()[-1] == '*':
            quit_msg = (
                "The workspace isn't saved. Are you sure you want to exit the program?"
            )
            reply = QtWidgets.QMessageBox.question(
                self,
                'Message',
                quit_msg,
                QtWidgets.QMessageBox.Yes,
                QtWidgets.QMessageBox.No,
            )

            if reply == QtWidgets.QMessageBox.Yes:
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()

    @staticmethod
    def show_help():
        """
        Shows compiled help file created using Dr. Explain
        """
        webbrowser.open('file://' + os.path.realpath('./docs/index.htm'))

    def dialog_about(self):
        if hasattr(self, 'commit'):
            AboutDialog(self.commit)
        else:
            AboutDialog('')

    def check_for_updates(self, show_uptodate_msg, parent=None):
        """
        Check if the usgs_root repo is at the same commit as this installation
        Parameters
        ----------
        e : qt event
        parent: Splash screen. Using this as the QMessageBox parent shows the MB
            centered over the splash screen.
        show_uptodate_msg : bool
           Whether to display a msg if no updates found
        Returns
        -------
        Booblean, whether or not to start GSadjust (True  yes)
        """
        try:
            gitpath = (
                os.path.dirname(self.path_install) + "\\gsadjust-env\\Lib\\mingw64\\bin"
            )
            os.environ["PATH"] += os.pathsep + gitpath
            from git import Repo

            logging.info('Checking for updates')
            repo = Repo(self.path_install)
            if not repo.active_branch.name == 'master':
                return True
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            for f in fetch:
                logging.info('Git fetched: {}'.format(f))
            self.commit = str(repo.head.commit)[:5]
            if repo.head.commit != master.commit:
                msg = "An update is available for GSadjust.\nWould you like to install now?"
                confirm = QtWidgets.QMessageBox.question(
                    parent,
                    "Update Available",
                    msg,
                    QtWidgets.QMessageBox.Yes | QtWidgets.QMessageBox.No,
                )
                if confirm == QtWidgets.QMessageBox.Yes:
                    return self.update_from_github()
            elif show_uptodate_msg:
                logging.info('Git checked, GSadjust is up to date.')
                msg = "GSadjust is up to date."
                QtWidgets.QMessageBox.information(self, "No Update Needed", msg)
                return True
            return True

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            if show_uptodate_msg:
                msg = 'Problem Encountered Updating from GitHub\n\nError Message:\n'
                msg += str(e)
                QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, start GSadjust anyway

    def update_from_github(self):
        """
        Merge the latest version of the Wizard into the local repo
        Returns
        -------
        None
        """

        try:
            from git import Repo

            # install_dir = utils.get_install_dname('pymdwizard')
            repo = Repo(self.path_install,)
            fetch = [r for r in repo.remotes if r.name == 'origin'][0].fetch()
            master = [f for f in fetch if f.name == 'origin/master'][0]
            repo.git.reset('--hard')
            repo.git.merge(master.name)
            logging.info('Git update successful')
            msg = (
                'Updated successfully downloaded from GitHub. Please\n'
                'restart GSadjust.'
            )
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return False  # Don't launch GSadjust, need to restart to install updates

        except BaseException as e:
            logging.info('Git update failed: {}'.format(e))
            msg = (
                'Problem Encountered Updating from GitHub\n\n'
                'Please upgrade to the latest release by reinstalling the '
                'application from GitHub '
                '\n(https://github.com/jkennedy-usgs/sgp-gsadjust/releases)\n\n'
                'Error Message:\n'
            )
            msg += str(e)
            QtWidgets.QMessageBox.information(self, "Update results", msg)
            return True  # Update didn't work, launch anyway

    def init_settings(self):
        """
        If it's the first time a user has opened ingestor, populate the
        directories/files

        :return: None
        """
        if self.settings.value('current_dir') is None:
            self.settings.setValue(
                'current_dir', os.path.join(os.getcwd(), 'test_data')
            )
        if self.settings.value('abs_g_path') is None:
            self.settings.setValue('abs_g_path', os.getcwd())
        if self.settings.value('tide_path') is None:
            self.settings.setValue('tide_path', os.getcwd())
        if self.settings.value('delta_table_column_widths') is None:
            self.settings.setValue('delta_table_column_widths', None)
        if self.settings.value('datum_table_column_widths') is None:
            self.settings.setValue('datum_table_column_widths', None)
        if self.settings.value('results_table_column_widths') is None:
            self.settings.setValue('results_table_column_widths', None)
        if self.settings.value('data_table_column_widths') is None:
            self.settings.setValue('data_table_column_widths', None)


class BoldDelegate(QtWidgets.QStyledItemDelegate):
    """
    Makes selected item in tree view bold.
    See     http://www.qtcentre.org/threads/61716-Set-the-color-of-a-row-in-a-qtreeview
    """

    def paint(self, painter, option, index):
        m = index.model().itemFromIndex(index)
        # decide here if item should be bold and set font weight to bold if needed
        if not hasattr(m, 'fontweight'):
            option.font.setWeight(QtGui.QFont.Normal)
            m.cellcolor = Qt.white
        else:
            option.font.setWeight(m.fontweight)
        painter.fillRect(option.rect, m.cellcolor)
        QtWidgets.QStyledItemDelegate.paint(self, painter, option, index)


def handle_exception(exc_type, exc_value, exc_traceback):
    """
    Sends exceptions to log file
    """
    # KeyboardInterrupt is a special case, don't raise the error dialog when it occurs.
    if issubclass(exc_type, KeyboardInterrupt):
        if QtWidgets.qApp:
            QtWidgets.qApp.quit()
        return

    filename, line, dummy, dummy = traceback.extract_tb(exc_traceback).pop()
    filename = os.path.basename(filename)
    error = "{}: {}".format(exc_type.__name__, exc_value)
    logging.error(error + " at line {:d} of file {}".format(line, filename))


DEBUG = False


def main():
    app = QtWidgets.QApplication(sys.argv)
    # GSadjust starts in different directories on Mac and Windows
    # FIXME: Shouldn't need to change path here, you can
    # find the location of the current folder (see __file__ elsewhere) and
    # use relative paths from there for your project.
    if sys.platform == 'darwin':
        os.chdir('../')
    else:
        os.chdir('../sgp-gsadjust')

    # start log file
    fn = 'GSadjustLog_' + time.strftime("%Y%m%d-%H%M") + '.txt'
    # Should probably change this to try a different location for the log file.
    try:
        logging.basicConfig(
            filename=fn, format='%(levelname)s:%(message)s', level=logging.INFO
        )
    except PermissionError:
        self.msg = show_message(
            'Please install GSadjust somewhere where admin rights are not required.',
            'GSadjust error',
        )

    splash_pix = QtGui.QPixmap(':/icons/Splash.png')
    splash = QtWidgets.QSplashScreen(splash_pix, Qt.WindowStaysOnTopHint)
    splash.setMask(splash_pix.mask())
    splash.show()
    ex = MainProg(splash=splash)
    app.processEvents()
    splash.finish(ex)
    app.setWindowIcon(QtGui.QIcon(':/icons/app.ico'))
    if not DEBUG:
        if ex.check_for_updates(False, parent=splash):
            # sys.excepthook = handle_exception
            ex.showMaximized()
            app.processEvents()
            app.exec_()
        else:
            ex.close()
    else:
        ex.showMaximized()
        app.processEvents()
        app.exec_()


if __name__ == '__main__':
    main()
